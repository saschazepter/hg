{
    "interactions": [
        {
            "response": {
                "headers": {
                    "x-content-type-options": [
                        "nosniff"
                    ], 
                    "x-xss-protection": [
                        "1; mode=block"
                    ], 
                    "content-type": [
                        "application/json"
                    ], 
                    "transfer-encoding": [
                        "chunked"
                    ], 
                    "strict-transport-security": [
                        "max-age=0; includeSubdomains; preload"
                    ], 
                    "date": [
                        "Fri, 17 Jan 2020 00:33:19 GMT"
                    ], 
                    "cache-control": [
                        "no-store"
                    ], 
                    "expires": [
                        "Sat, 01 Jan 2000 00:00:00 GMT"
                    ], 
                    "server": [
                        "Apache/2.4.10 (Debian)"
                    ], 
                    "x-frame-options": [
                        "Deny"
                    ], 
                    "referrer-policy": [
                        "no-referrer"
                    ]
                }, 
                "status": {
                    "code": 200, 
                    "message": "OK"
                }, 
                "body": {
                    "string": "{\"result\":[{\"id\":\"1285\",\"phid\":\"PHID-DREV-j3rjfvsetkqtvhk6dxye\",\"title\":\"repoview: add a new attribute _visibilityexceptions and related API\",\"uri\":\"https:\\/\\/phab.mercurial-scm.org\\/D1285\",\"dateCreated\":\"1509645891\",\"dateModified\":\"1515574368\",\"authorPHID\":\"PHID-USER-34jnztnonbr4lhwuybwl\",\"status\":\"4\",\"statusName\":\"Abandoned\",\"properties\":[],\"branch\":null,\"summary\":\"Currently we don't have a defined way in core to make some hidden revisions\\nvisible in filtered repo. Extensions to achieve the purpose of unhiding some\\nhidden commits, wrap repoview.pinnedrevs() function.\\n\\nTo make the above task simple and have well defined API, this patch adds a new\\nattribute '_visibilityexceptions' to repoview class which will contains\\nthe hidden revs which should be exception.\\nThis will allow to set different exceptions for different repoview objects\\nbacked by the same unfiltered repo.\\n\\nThis patch also adds API to add revs to the attribute set and get them.\\n\\nThanks to Jun for suggesting the use of repoview class instead of localrepo.\",\"testPlan\":\"\",\"lineCount\":\"19\",\"activeDiffPHID\":\"PHID-DIFF-mpgcio4dbd3k3ab2ha6x\",\"diffs\":[\"4092\",\"4051\",\"3956\",\"3784\",\"3201\"],\"commits\":[],\"reviewers\":{\"PHID-PROJ-3dvcxzznrjru2xmmses3\":\"PHID-PROJ-3dvcxzznrjru2xmmses3\",\"PHID-USER-bdvomxbzdb42dlftorg4\":\"PHID-USER-bdvomxbzdb42dlftorg4\",\"PHID-USER-qwhdxkyioew7vwvxqc2g\":\"PHID-USER-qwhdxkyioew7vwvxqc2g\"},\"ccs\":[\"PHID-USER-qwhdxkyioew7vwvxqc2g\",\"PHID-USER-f6tllotq6q2rtpi47wjq\",\"PHID-USER-bdvomxbzdb42dlftorg4\",\"PHID-USER-q42dn7cc3donqriafhjx\"],\"hashes\":[],\"auxiliary\":{\"phabricator:projects\":[],\"phabricator:depends-on\":[]},\"repositoryPHID\":\"PHID-REPO-bvunnehri4u2isyr7bc3\"}],\"error_code\":null,\"error_info\":null}"
                }
            }, 
            "request": {
                "method": "POST", 
                "uri": "https://phab.mercurial-scm.org//api/differential.query", 
                "headers": {
                    "content-type": [
                        "application/x-www-form-urlencoded"
                    ], 
                    "user-agent": [
                        "mercurial/proto-1.0 (Mercurial 5.2.2+620-6ee2ba170fe6+20200116)"
                    ], 
                    "accept": [
                        "application/mercurial-0.1"
                    ], 
                    "content-length": [
                        "146"
                    ], 
                    "host": [
                        "phab.mercurial-scm.org"
                    ]
                }, 
                "body": "params=%7B%22__conduit__%22%3A+%7B%22token%22%3A+%22cli-hahayouwish%22%7D%2C+%22ids%22%3A+%5B1285%5D%7D&output=json&__conduit__=1"
            }
        }, 
        {
            "response": {
                "headers": {
                    "x-content-type-options": [
                        "nosniff"
                    ], 
                    "x-xss-protection": [
                        "1; mode=block"
                    ], 
                    "content-type": [
                        "application/json"
                    ], 
                    "transfer-encoding": [
                        "chunked"
                    ], 
                    "strict-transport-security": [
                        "max-age=0; includeSubdomains; preload"
                    ], 
                    "date": [
                        "Fri, 17 Jan 2020 00:33:20 GMT"
                    ], 
                    "cache-control": [
                        "no-store"
                    ], 
                    "expires": [
                        "Sat, 01 Jan 2000 00:00:00 GMT"
                    ], 
                    "server": [
                        "Apache/2.4.10 (Debian)"
                    ], 
                    "x-frame-options": [
                        "Deny"
                    ], 
                    "referrer-policy": [
                        "no-referrer"
                    ]
                }, 
                "status": {
                    "code": 200, 
                    "message": "OK"
                }, 
                "body": {
                    "string": "{\"result\":{\"4092\":{\"id\":\"4092\",\"revisionID\":\"1285\",\"dateCreated\":\"1512396989\",\"dateModified\":\"1512396993\",\"sourceControlBaseRevision\":null,\"sourceControlPath\":null,\"sourceControlSystem\":null,\"branch\":null,\"bookmark\":null,\"creationMethod\":\"web\",\"description\":null,\"unitStatus\":\"4\",\"lintStatus\":\"4\",\"changes\":[{\"id\":\"9311\",\"metadata\":{\"line:first\":188},\"oldPath\":\"mercurial\\/repoview.py\",\"currentPath\":\"mercurial\\/repoview.py\",\"awayPaths\":[],\"oldProperties\":[],\"newProperties\":[],\"type\":\"2\",\"fileType\":\"1\",\"commitHash\":null,\"addLines\":\"11\",\"delLines\":\"0\",\"hunks\":[{\"oldOffset\":\"1\",\"newOffset\":\"1\",\"oldLength\":\"242\",\"newLength\":\"253\",\"addLines\":null,\"delLines\":null,\"isMissingOldNewline\":null,\"isMissingNewNewline\":null,\"corpus\":\" # repoview.py - Filtered view of a localrepo object\\n #\\n # Copyright 2012 Pierre-Yves David \\u003cpierre-yves.david@ens-lyon.org\\u003e\\n #                Logilab SA        \\u003ccontact@logilab.fr\\u003e\\n #\\n # This software may be used and distributed according to the terms of the\\n # GNU General Public License version 2 or any later version.\\n \\n from __future__ import absolute_import\\n \\n import copy\\n \\n from .node import nullrev\\n from . import (\\n     obsolete,\\n     phases,\\n     tags as tagsmod,\\n )\\n \\n def hideablerevs(repo):\\n     \\\"\\\"\\\"Revision candidates to be hidden\\n \\n     This is a standalone function to allow extensions to wrap it.\\n \\n     Because we use the set of immutable changesets as a fallback subset in\\n     branchmap (see mercurial.branchmap.subsettable), you cannot set \\\"public\\\"\\n     changesets as \\\"hideable\\\". Doing so would break multiple code assertions and\\n     lead to crashes.\\\"\\\"\\\"\\n     return obsolete.getrevs(repo, 'obsolete')\\n \\n def pinnedrevs(repo):\\n     \\\"\\\"\\\"revisions blocking hidden changesets from being filtered\\n     \\\"\\\"\\\"\\n \\n     cl = repo.changelog\\n     pinned = set()\\n     pinned.update([par.rev() for par in repo[None].parents()])\\n     pinned.update([cl.rev(bm) for bm in repo._bookmarks.values()])\\n \\n     tags = {}\\n     tagsmod.readlocaltags(repo.ui, repo, tags, {})\\n     if tags:\\n         rev, nodemap = cl.rev, cl.nodemap\\n         pinned.update(rev(t[0]) for t in tags.values() if t[0] in nodemap)\\n     return pinned\\n \\n \\n def _revealancestors(pfunc, hidden, revs):\\n     \\\"\\\"\\\"reveals contiguous chains of hidden ancestors of 'revs' by removing them\\n     from 'hidden'\\n \\n     - pfunc(r): a funtion returning parent of 'r',\\n     - hidden: the (preliminary) hidden revisions, to be updated\\n     - revs: iterable of revnum,\\n \\n     (Ancestors are revealed exclusively, i.e. the elements in 'revs' are\\n     *not* revealed)\\n     \\\"\\\"\\\"\\n     stack = list(revs)\\n     while stack:\\n         for p in pfunc(stack.pop()):\\n             if p != nullrev and p in hidden:\\n                 hidden.remove(p)\\n                 stack.append(p)\\n \\n def computehidden(repo):\\n     \\\"\\\"\\\"compute the set of hidden revision to filter\\n \\n     During most operation hidden should be filtered.\\\"\\\"\\\"\\n     assert not repo.changelog.filteredrevs\\n \\n     hidden = hideablerevs(repo)\\n     if hidden:\\n         hidden = set(hidden - pinnedrevs(repo))\\n         pfunc = repo.changelog.parentrevs\\n         mutablephases = (phases.draft, phases.secret)\\n         mutable = repo._phasecache.getrevset(repo, mutablephases)\\n \\n         visible = mutable - hidden\\n         _revealancestors(pfunc, hidden, visible)\\n     return frozenset(hidden)\\n \\n def computeunserved(repo):\\n     \\\"\\\"\\\"compute the set of revision that should be filtered when used a server\\n \\n     Secret and hidden changeset should not pretend to be here.\\\"\\\"\\\"\\n     assert not repo.changelog.filteredrevs\\n     # fast path in simple case to avoid impact of non optimised code\\n     hiddens = filterrevs(repo, 'visible')\\n     if phases.hassecret(repo):\\n         cl = repo.changelog\\n         secret = phases.secret\\n         getphase = repo._phasecache.phase\\n         first = min(cl.rev(n) for n in repo._phasecache.phaseroots[secret])\\n         revs = cl.revs(start=first)\\n         secrets = set(r for r in revs if getphase(repo, r) \\u003e= secret)\\n         return frozenset(hiddens | secrets)\\n     else:\\n         return hiddens\\n \\n def computemutable(repo):\\n     assert not repo.changelog.filteredrevs\\n     # fast check to avoid revset call on huge repo\\n     if any(repo._phasecache.phaseroots[1:]):\\n         getphase = repo._phasecache.phase\\n         maymutable = filterrevs(repo, 'base')\\n         return frozenset(r for r in maymutable if getphase(repo, r))\\n     return frozenset()\\n \\n def computeimpactable(repo):\\n     \\\"\\\"\\\"Everything impactable by mutable revision\\n \\n     The immutable filter still have some chance to get invalidated. This will\\n     happen when:\\n \\n     - you garbage collect hidden changeset,\\n     - public phase is moved backward,\\n     - something is changed in the filtering (this could be fixed)\\n \\n     This filter out any mutable changeset and any public changeset that may be\\n     impacted by something happening to a mutable revision.\\n \\n     This is achieved by filtered everything with a revision number egal or\\n     higher than the first mutable changeset is filtered.\\\"\\\"\\\"\\n     assert not repo.changelog.filteredrevs\\n     cl = repo.changelog\\n     firstmutable = len(cl)\\n     for roots in repo._phasecache.phaseroots[1:]:\\n         if roots:\\n             firstmutable = min(firstmutable, min(cl.rev(r) for r in roots))\\n     # protect from nullrev root\\n     firstmutable = max(0, firstmutable)\\n     return frozenset(xrange(firstmutable, len(cl)))\\n \\n # function to compute filtered set\\n #\\n # When adding a new filter you MUST update the table at:\\n #     mercurial.branchmap.subsettable\\n # Otherwise your filter will have to recompute all its branches cache\\n # from scratch (very slow).\\n filtertable = {'visible': computehidden,\\n                'served': computeunserved,\\n                'immutable':  computemutable,\\n                'base':  computeimpactable}\\n \\n def filterrevs(repo, filtername):\\n     \\\"\\\"\\\"returns set of filtered revision for this filter name\\\"\\\"\\\"\\n     if filtername not in repo.filteredrevcache:\\n         func = filtertable[filtername]\\n         repo.filteredrevcache[filtername] = func(repo.unfiltered())\\n     return repo.filteredrevcache[filtername]\\n \\n class repoview(object):\\n     \\\"\\\"\\\"Provide a read\\/write view of a repo through a filtered changelog\\n \\n     This object is used to access a filtered version of a repository without\\n     altering the original repository object itself. We can not alter the\\n     original object for two main reasons:\\n     - It prevents the use of a repo with multiple filters at the same time. In\\n       particular when multiple threads are involved.\\n     - It makes scope of the filtering harder to control.\\n \\n     This object behaves very closely to the original repository. All attribute\\n     operations are done on the original repository:\\n     - An access to `repoview.someattr` actually returns `repo.someattr`,\\n     - A write to `repoview.someattr` actually sets value of `repo.someattr`,\\n     - A deletion of `repoview.someattr` actually drops `someattr`\\n       from `repo.__dict__`.\\n \\n     The only exception is the `changelog` property. It is overridden to return\\n     a (surface) copy of `repo.changelog` with some revisions filtered. The\\n     `filtername` attribute of the view control the revisions that need to be\\n     filtered.  (the fact the changelog is copied is an implementation detail).\\n \\n     Unlike attributes, this object intercepts all method calls. This means that\\n     all methods are run on the `repoview` object with the filtered `changelog`\\n     property. For this purpose the simple `repoview` class must be mixed with\\n     the actual class of the repository. This ensures that the resulting\\n     `repoview` object have the very same methods than the repo object. This\\n     leads to the property below.\\n \\n         repoview.method() --\\u003e repo.__class__.method(repoview)\\n \\n     The inheritance has to be done dynamically because `repo` can be of any\\n     subclasses of `localrepo`. Eg: `bundlerepo` or `statichttprepo`.\\n     \\\"\\\"\\\"\\n \\n+    # hidden revs which should be visible\\n+    _visibilityexceptions = set()\\n+\\n     def __init__(self, repo, filtername):\\n         object.__setattr__(self, r'_unfilteredrepo', repo)\\n         object.__setattr__(self, r'filtername', filtername)\\n         object.__setattr__(self, r'_clcachekey', None)\\n         object.__setattr__(self, r'_clcache', None)\\n \\n     # not a propertycache on purpose we shall implement a proper cache later\\n     @property\\n     def changelog(self):\\n         \\\"\\\"\\\"return a filtered version of the changeset\\n \\n         this changelog must not be used for writing\\\"\\\"\\\"\\n         # some cache may be implemented later\\n         unfi = self._unfilteredrepo\\n         unfichangelog = unfi.changelog\\n         # bypass call to changelog.method\\n         unfiindex = unfichangelog.index\\n         unfilen = len(unfiindex) - 1\\n         unfinode = unfiindex[unfilen - 1][7]\\n \\n         revs = filterrevs(unfi, self.filtername)\\n         cl = self._clcache\\n         newkey = (unfilen, unfinode, hash(revs), unfichangelog._delayed)\\n         # if cl.index is not unfiindex, unfi.changelog would be\\n         # recreated, and our clcache refers to garbage object\\n         if (cl is not None and\\n             (cl.index is not unfiindex or newkey != self._clcachekey)):\\n             cl = None\\n         # could have been made None by the previous if\\n         if cl is None:\\n             cl = copy.copy(unfichangelog)\\n             cl.filteredrevs = revs\\n             object.__setattr__(self, r'_clcache', cl)\\n             object.__setattr__(self, r'_clcachekey', newkey)\\n         return cl\\n \\n     def unfiltered(self):\\n         \\\"\\\"\\\"Return an unfiltered version of a repo\\\"\\\"\\\"\\n         return self._unfilteredrepo\\n \\n     def filtered(self, name):\\n         \\\"\\\"\\\"Return a filtered version of a repository\\\"\\\"\\\"\\n         if name == self.filtername:\\n             return self\\n         return self.unfiltered().filtered(name)\\n \\n+    def addvisibilityexceptions(self, revs):\\n+        \\\"\\\"\\\"adds hidden revs which should be visible to set of exceptions\\\"\\\"\\\"\\n+        self._visibilityexceptions.update(revs)\\n+\\n+    def getvisibilityexceptions(self):\\n+        \\\"\\\"\\\"returns the set of hidden revs which should be visible\\\"\\\"\\\"\\n+        return self._visibilityexceptions\\n+\\n     # everything access are forwarded to the proxied repo\\n     def __getattr__(self, attr):\\n         return getattr(self._unfilteredrepo, attr)\\n \\n     def __setattr__(self, attr, value):\\n         return setattr(self._unfilteredrepo, attr, value)\\n \\n     def __delattr__(self, attr):\\n         return delattr(self._unfilteredrepo, attr)\\n\"}]},{\"id\":\"9310\",\"metadata\":{\"line:first\":573},\"oldPath\":\"mercurial\\/localrepo.py\",\"currentPath\":\"mercurial\\/localrepo.py\",\"awayPaths\":[],\"oldProperties\":[],\"newProperties\":[],\"type\":\"2\",\"fileType\":\"1\",\"commitHash\":null,\"addLines\":\"8\",\"delLines\":\"0\",\"hunks\":[{\"oldOffset\":\"1\",\"newOffset\":\"1\",\"oldLength\":\"2301\",\"newLength\":\"2309\",\"addLines\":null,\"delLines\":null,\"isMissingOldNewline\":null,\"isMissingNewNewline\":null,\"corpus\":\" # localrepo.py - read\\/write repository class for mercurial\\n #\\n # Copyright 2005-2007 Matt Mackall \\u003cmpm@selenic.com\\u003e\\n #\\n # This software may be used and distributed according to the terms of the\\n # GNU General Public License version 2 or any later version.\\n \\n from __future__ import absolute_import\\n \\n import errno\\n import hashlib\\n import inspect\\n import os\\n import random\\n import time\\n import weakref\\n \\n from .i18n import _\\n from .node import (\\n     hex,\\n     nullid,\\n     short,\\n )\\n from . import (\\n     bookmarks,\\n     branchmap,\\n     bundle2,\\n     changegroup,\\n     changelog,\\n     color,\\n     context,\\n     dirstate,\\n     dirstateguard,\\n     discovery,\\n     encoding,\\n     error,\\n     exchange,\\n     extensions,\\n     filelog,\\n     hook,\\n     lock as lockmod,\\n     manifest,\\n     match as matchmod,\\n     merge as mergemod,\\n     mergeutil,\\n     namespaces,\\n     obsolete,\\n     pathutil,\\n     peer,\\n     phases,\\n     pushkey,\\n     pycompat,\\n     repository,\\n     repoview,\\n     revset,\\n     revsetlang,\\n     scmutil,\\n     sparse,\\n     store,\\n     subrepo,\\n     tags as tagsmod,\\n     transaction,\\n     txnutil,\\n     util,\\n     vfs as vfsmod,\\n )\\n \\n release = lockmod.release\\n urlerr = util.urlerr\\n urlreq = util.urlreq\\n \\n # set of (path, vfs-location) tuples. vfs-location is:\\n # - 'plain for vfs relative paths\\n # - '' for svfs relative paths\\n _cachedfiles = set()\\n \\n class _basefilecache(scmutil.filecache):\\n     \\\"\\\"\\\"All filecache usage on repo are done for logic that should be unfiltered\\n     \\\"\\\"\\\"\\n     def __get__(self, repo, type=None):\\n         if repo is None:\\n             return self\\n         return super(_basefilecache, self).__get__(repo.unfiltered(), type)\\n     def __set__(self, repo, value):\\n         return super(_basefilecache, self).__set__(repo.unfiltered(), value)\\n     def __delete__(self, repo):\\n         return super(_basefilecache, self).__delete__(repo.unfiltered())\\n \\n class repofilecache(_basefilecache):\\n     \\\"\\\"\\\"filecache for files in .hg but outside of .hg\\/store\\\"\\\"\\\"\\n     def __init__(self, *paths):\\n         super(repofilecache, self).__init__(*paths)\\n         for path in paths:\\n             _cachedfiles.add((path, 'plain'))\\n \\n     def join(self, obj, fname):\\n         return obj.vfs.join(fname)\\n \\n class storecache(_basefilecache):\\n     \\\"\\\"\\\"filecache for files in the store\\\"\\\"\\\"\\n     def __init__(self, *paths):\\n         super(storecache, self).__init__(*paths)\\n         for path in paths:\\n             _cachedfiles.add((path, ''))\\n \\n     def join(self, obj, fname):\\n         return obj.sjoin(fname)\\n \\n def isfilecached(repo, name):\\n     \\\"\\\"\\\"check if a repo has already cached \\\"name\\\" filecache-ed property\\n \\n     This returns (cachedobj-or-None, iscached) tuple.\\n     \\\"\\\"\\\"\\n     cacheentry = repo.unfiltered()._filecache.get(name, None)\\n     if not cacheentry:\\n         return None, False\\n     return cacheentry.obj, True\\n \\n class unfilteredpropertycache(util.propertycache):\\n     \\\"\\\"\\\"propertycache that apply to unfiltered repo only\\\"\\\"\\\"\\n \\n     def __get__(self, repo, type=None):\\n         unfi = repo.unfiltered()\\n         if unfi is repo:\\n             return super(unfilteredpropertycache, self).__get__(unfi)\\n         return getattr(unfi, self.name)\\n \\n class filteredpropertycache(util.propertycache):\\n     \\\"\\\"\\\"propertycache that must take filtering in account\\\"\\\"\\\"\\n \\n     def cachevalue(self, obj, value):\\n         object.__setattr__(obj, self.name, value)\\n \\n \\n def hasunfilteredcache(repo, name):\\n     \\\"\\\"\\\"check if a repo has an unfilteredpropertycache value for \\u003cname\\u003e\\\"\\\"\\\"\\n     return name in vars(repo.unfiltered())\\n \\n def unfilteredmethod(orig):\\n     \\\"\\\"\\\"decorate method that always need to be run on unfiltered version\\\"\\\"\\\"\\n     def wrapper(repo, *args, **kwargs):\\n         return orig(repo.unfiltered(), *args, **kwargs)\\n     return wrapper\\n \\n moderncaps = {'lookup', 'branchmap', 'pushkey', 'known', 'getbundle',\\n               'unbundle'}\\n legacycaps = moderncaps.union({'changegroupsubset'})\\n \\n class localpeer(repository.peer):\\n     '''peer for a local repo; reflects only the most recent API'''\\n \\n     def __init__(self, repo, caps=None):\\n         super(localpeer, self).__init__()\\n \\n         if caps is None:\\n             caps = moderncaps.copy()\\n         self._repo = repo.filtered('served')\\n         self._ui = repo.ui\\n         self._caps = repo._restrictcapabilities(caps)\\n \\n     # Begin of _basepeer interface.\\n \\n     @util.propertycache\\n     def ui(self):\\n         return self._ui\\n \\n     def url(self):\\n         return self._repo.url()\\n \\n     def local(self):\\n         return self._repo\\n \\n     def peer(self):\\n         return self\\n \\n     def canpush(self):\\n         return True\\n \\n     def close(self):\\n         self._repo.close()\\n \\n     # End of _basepeer interface.\\n \\n     # Begin of _basewirecommands interface.\\n \\n     def branchmap(self):\\n         return self._repo.branchmap()\\n \\n     def capabilities(self):\\n         return self._caps\\n \\n     def debugwireargs(self, one, two, three=None, four=None, five=None):\\n         \\\"\\\"\\\"Used to test argument passing over the wire\\\"\\\"\\\"\\n         return \\\"%s %s %s %s %s\\\" % (one, two, three, four, five)\\n \\n     def getbundle(self, source, heads=None, common=None, bundlecaps=None,\\n                   **kwargs):\\n         chunks = exchange.getbundlechunks(self._repo, source, heads=heads,\\n                                           common=common, bundlecaps=bundlecaps,\\n                                           **kwargs)\\n         cb = util.chunkbuffer(chunks)\\n \\n         if exchange.bundle2requested(bundlecaps):\\n             # When requesting a bundle2, getbundle returns a stream to make the\\n             # wire level function happier. We need to build a proper object\\n             # from it in local peer.\\n             return bundle2.getunbundler(self.ui, cb)\\n         else:\\n             return changegroup.getunbundler('01', cb, None)\\n \\n     def heads(self):\\n         return self._repo.heads()\\n \\n     def known(self, nodes):\\n         return self._repo.known(nodes)\\n \\n     def listkeys(self, namespace):\\n         return self._repo.listkeys(namespace)\\n \\n     def lookup(self, key):\\n         return self._repo.lookup(key)\\n \\n     def pushkey(self, namespace, key, old, new):\\n         return self._repo.pushkey(namespace, key, old, new)\\n \\n     def stream_out(self):\\n         raise error.Abort(_('cannot perform stream clone against local '\\n                             'peer'))\\n \\n     def unbundle(self, cg, heads, url):\\n         \\\"\\\"\\\"apply a bundle on a repo\\n \\n         This function handles the repo locking itself.\\\"\\\"\\\"\\n         try:\\n             try:\\n                 cg = exchange.readbundle(self.ui, cg, None)\\n                 ret = exchange.unbundle(self._repo, cg, heads, 'push', url)\\n                 if util.safehasattr(ret, 'getchunks'):\\n                     # This is a bundle20 object, turn it into an unbundler.\\n                     # This little dance should be dropped eventually when the\\n                     # API is finally improved.\\n                     stream = util.chunkbuffer(ret.getchunks())\\n                     ret = bundle2.getunbundler(self.ui, stream)\\n                 return ret\\n             except Exception as exc:\\n                 # If the exception contains output salvaged from a bundle2\\n                 # reply, we need to make sure it is printed before continuing\\n                 # to fail. So we build a bundle2 with such output and consume\\n                 # it directly.\\n                 #\\n                 # This is not very elegant but allows a \\\"simple\\\" solution for\\n                 # issue4594\\n                 output = getattr(exc, '_bundle2salvagedoutput', ())\\n                 if output:\\n                     bundler = bundle2.bundle20(self._repo.ui)\\n                     for out in output:\\n                         bundler.addpart(out)\\n                     stream = util.chunkbuffer(bundler.getchunks())\\n                     b = bundle2.getunbundler(self.ui, stream)\\n                     bundle2.processbundle(self._repo, b)\\n                 raise\\n         except error.PushRaced as exc:\\n             raise error.ResponseError(_('push failed:'), str(exc))\\n \\n     # End of _basewirecommands interface.\\n \\n     # Begin of peer interface.\\n \\n     def iterbatch(self):\\n         return peer.localiterbatcher(self)\\n \\n     # End of peer interface.\\n \\n class locallegacypeer(repository.legacypeer, localpeer):\\n     '''peer extension which implements legacy methods too; used for tests with\\n     restricted capabilities'''\\n \\n     def __init__(self, repo):\\n         super(locallegacypeer, self).__init__(repo, caps=legacycaps)\\n \\n     # Begin of baselegacywirecommands interface.\\n \\n     def between(self, pairs):\\n         return self._repo.between(pairs)\\n \\n     def branches(self, nodes):\\n         return self._repo.branches(nodes)\\n \\n     def changegroup(self, basenodes, source):\\n         outgoing = discovery.outgoing(self._repo, missingroots=basenodes,\\n                                       missingheads=self._repo.heads())\\n         return changegroup.makechangegroup(self._repo, outgoing, '01', source)\\n \\n     def changegroupsubset(self, bases, heads, source):\\n         outgoing = discovery.outgoing(self._repo, missingroots=bases,\\n                                       missingheads=heads)\\n         return changegroup.makechangegroup(self._repo, outgoing, '01', source)\\n \\n     # End of baselegacywirecommands interface.\\n \\n # Increment the sub-version when the revlog v2 format changes to lock out old\\n # clients.\\n REVLOGV2_REQUIREMENT = 'exp-revlogv2.0'\\n \\n class localrepository(object):\\n \\n     supportedformats = {\\n         'revlogv1',\\n         'generaldelta',\\n         'treemanifest',\\n         'manifestv2',\\n         REVLOGV2_REQUIREMENT,\\n     }\\n     _basesupported = supportedformats | {\\n         'store',\\n         'fncache',\\n         'shared',\\n         'relshared',\\n         'dotencode',\\n         'exp-sparse',\\n     }\\n     openerreqs = {\\n         'revlogv1',\\n         'generaldelta',\\n         'treemanifest',\\n         'manifestv2',\\n     }\\n \\n     # a list of (ui, featureset) functions.\\n     # only functions defined in module of enabled extensions are invoked\\n     featuresetupfuncs = set()\\n \\n     # list of prefix for file which can be written without 'wlock'\\n     # Extensions should extend this list when needed\\n     _wlockfreeprefix = {\\n         # We migh consider requiring 'wlock' for the next\\n         # two, but pretty much all the existing code assume\\n         # wlock is not needed so we keep them excluded for\\n         # now.\\n         'hgrc',\\n         'requires',\\n         # XXX cache is a complicatged business someone\\n         # should investigate this in depth at some point\\n         'cache\\/',\\n         # XXX shouldn't be dirstate covered by the wlock?\\n         'dirstate',\\n         # XXX bisect was still a bit too messy at the time\\n         # this changeset was introduced. Someone should fix\\n         # the remainig bit and drop this line\\n         'bisect.state',\\n     }\\n \\n     def __init__(self, baseui, path, create=False):\\n         self.requirements = set()\\n         self.filtername = None\\n         # wvfs: rooted at the repository root, used to access the working copy\\n         self.wvfs = vfsmod.vfs(path, expandpath=True, realpath=True)\\n         # vfs: rooted at .hg, used to access repo files outside of .hg\\/store\\n         self.vfs = None\\n         # svfs: usually rooted at .hg\\/store, used to access repository history\\n         # If this is a shared repository, this vfs may point to another\\n         # repository's .hg\\/store directory.\\n         self.svfs = None\\n         self.root = self.wvfs.base\\n         self.path = self.wvfs.join(\\\".hg\\\")\\n         self.origroot = path\\n         # This is only used by context.workingctx.match in order to\\n         # detect files in subrepos.\\n         self.auditor = pathutil.pathauditor(\\n             self.root, callback=self._checknested)\\n         # This is only used by context.basectx.match in order to detect\\n         # files in subrepos.\\n         self.nofsauditor = pathutil.pathauditor(\\n             self.root, callback=self._checknested, realfs=False, cached=True)\\n         self.baseui = baseui\\n         self.ui = baseui.copy()\\n         self.ui.copy = baseui.copy # prevent copying repo configuration\\n         self.vfs = vfsmod.vfs(self.path, cacheaudited=True)\\n         if (self.ui.configbool('devel', 'all-warnings') or\\n             self.ui.configbool('devel', 'check-locks')):\\n             self.vfs.audit = self._getvfsward(self.vfs.audit)\\n         # A list of callback to shape the phase if no data were found.\\n         # Callback are in the form: func(repo, roots) --\\u003e processed root.\\n         # This list it to be filled by extension during repo setup\\n         self._phasedefaults = []\\n         try:\\n             self.ui.readconfig(self.vfs.join(\\\"hgrc\\\"), self.root)\\n             self._loadextensions()\\n         except IOError:\\n             pass\\n \\n         if self.featuresetupfuncs:\\n             self.supported = set(self._basesupported) # use private copy\\n             extmods = set(m.__name__ for n, m\\n                           in extensions.extensions(self.ui))\\n             for setupfunc in self.featuresetupfuncs:\\n                 if setupfunc.__module__ in extmods:\\n                     setupfunc(self.ui, self.supported)\\n         else:\\n             self.supported = self._basesupported\\n         color.setup(self.ui)\\n \\n         # Add compression engines.\\n         for name in util.compengines:\\n             engine = util.compengines[name]\\n             if engine.revlogheader():\\n                 self.supported.add('exp-compression-%s' % name)\\n \\n         if not self.vfs.isdir():\\n             if create:\\n                 self.requirements = newreporequirements(self)\\n \\n                 if not self.wvfs.exists():\\n                     self.wvfs.makedirs()\\n                 self.vfs.makedir(notindexed=True)\\n \\n                 if 'store' in self.requirements:\\n                     self.vfs.mkdir(\\\"store\\\")\\n \\n                     # create an invalid changelog\\n                     self.vfs.append(\\n                         \\\"00changelog.i\\\",\\n                         '\\\\0\\\\0\\\\0\\\\2' # represents revlogv2\\n                         ' dummy changelog to prevent using the old repo layout'\\n                     )\\n             else:\\n                 raise error.RepoError(_(\\\"repository %s not found\\\") % path)\\n         elif create:\\n             raise error.RepoError(_(\\\"repository %s already exists\\\") % path)\\n         else:\\n             try:\\n                 self.requirements = scmutil.readrequires(\\n                         self.vfs, self.supported)\\n             except IOError as inst:\\n                 if inst.errno != errno.ENOENT:\\n                     raise\\n \\n         cachepath = self.vfs.join('cache')\\n         self.sharedpath = self.path\\n         try:\\n             sharedpath = self.vfs.read(\\\"sharedpath\\\").rstrip('\\\\n')\\n             if 'relshared' in self.requirements:\\n                 sharedpath = self.vfs.join(sharedpath)\\n             vfs = vfsmod.vfs(sharedpath, realpath=True)\\n             cachepath = vfs.join('cache')\\n             s = vfs.base\\n             if not vfs.exists():\\n                 raise error.RepoError(\\n                     _('.hg\\/sharedpath points to nonexistent directory %s') % s)\\n             self.sharedpath = s\\n         except IOError as inst:\\n             if inst.errno != errno.ENOENT:\\n                 raise\\n \\n         if 'exp-sparse' in self.requirements and not sparse.enabled:\\n             raise error.RepoError(_('repository is using sparse feature but '\\n                                     'sparse is not enabled; enable the '\\n                                     '\\\"sparse\\\" extensions to access'))\\n \\n         self.store = store.store(\\n             self.requirements, self.sharedpath,\\n             lambda base: vfsmod.vfs(base, cacheaudited=True))\\n         self.spath = self.store.path\\n         self.svfs = self.store.vfs\\n         self.sjoin = self.store.join\\n         self.vfs.createmode = self.store.createmode\\n         self.cachevfs = vfsmod.vfs(cachepath, cacheaudited=True)\\n         self.cachevfs.createmode = self.store.createmode\\n         if (self.ui.configbool('devel', 'all-warnings') or\\n             self.ui.configbool('devel', 'check-locks')):\\n             if util.safehasattr(self.svfs, 'vfs'): # this is filtervfs\\n                 self.svfs.vfs.audit = self._getsvfsward(self.svfs.vfs.audit)\\n             else: # standard vfs\\n                 self.svfs.audit = self._getsvfsward(self.svfs.audit)\\n         self._applyopenerreqs()\\n         if create:\\n             self._writerequirements()\\n \\n         self._dirstatevalidatewarned = False\\n \\n         self._branchcaches = {}\\n         self._revbranchcache = None\\n         self.filterpats = {}\\n         self._datafilters = {}\\n         self._transref = self._lockref = self._wlockref = None\\n \\n         # A cache for various files under .hg\\/ that tracks file changes,\\n         # (used by the filecache decorator)\\n         #\\n         # Maps a property name to its util.filecacheentry\\n         self._filecache = {}\\n \\n         # hold sets of revision to be filtered\\n         # should be cleared when something might have changed the filter value:\\n         # - new changesets,\\n         # - phase change,\\n         # - new obsolescence marker,\\n         # - working directory parent change,\\n         # - bookmark changes\\n         self.filteredrevcache = {}\\n \\n         # post-dirstate-status hooks\\n         self._postdsstatus = []\\n \\n         # Cache of types representing filtered repos.\\n         self._filteredrepotypes = weakref.WeakKeyDictionary()\\n \\n         # generic mapping between names and nodes\\n         self.names = namespaces.namespaces()\\n \\n         # Key to signature value.\\n         self._sparsesignaturecache = {}\\n         # Signature to cached matcher instance.\\n         self._sparsematchercache = {}\\n \\n     def _getvfsward(self, origfunc):\\n         \\\"\\\"\\\"build a ward for self.vfs\\\"\\\"\\\"\\n         rref = weakref.ref(self)\\n         def checkvfs(path, mode=None):\\n             ret = origfunc(path, mode=mode)\\n             repo = rref()\\n             if (repo is None\\n                 or not util.safehasattr(repo, '_wlockref')\\n                 or not util.safehasattr(repo, '_lockref')):\\n                 return\\n             if mode in (None, 'r', 'rb'):\\n                 return\\n             if path.startswith(repo.path):\\n                 # truncate name relative to the repository (.hg)\\n                 path = path[len(repo.path) + 1:]\\n             if path.startswith('cache\\/'):\\n                 msg = 'accessing cache with vfs instead of cachevfs: \\\"%s\\\"'\\n                 repo.ui.develwarn(msg % path, stacklevel=2, config=\\\"cache-vfs\\\")\\n             if path.startswith('journal.'):\\n                 # journal is covered by 'lock'\\n                 if repo._currentlock(repo._lockref) is None:\\n                     repo.ui.develwarn('write with no lock: \\\"%s\\\"' % path,\\n                                       stacklevel=2, config='check-locks')\\n             elif repo._currentlock(repo._wlockref) is None:\\n                 # rest of vfs files are covered by 'wlock'\\n                 #\\n                 # exclude special files\\n                 for prefix in self._wlockfreeprefix:\\n                     if path.startswith(prefix):\\n                         return\\n                 repo.ui.develwarn('write with no wlock: \\\"%s\\\"' % path,\\n                                   stacklevel=2, config='check-locks')\\n             return ret\\n         return checkvfs\\n \\n     def _getsvfsward(self, origfunc):\\n         \\\"\\\"\\\"build a ward for self.svfs\\\"\\\"\\\"\\n         rref = weakref.ref(self)\\n         def checksvfs(path, mode=None):\\n             ret = origfunc(path, mode=mode)\\n             repo = rref()\\n             if repo is None or not util.safehasattr(repo, '_lockref'):\\n                 return\\n             if mode in (None, 'r', 'rb'):\\n                 return\\n             if path.startswith(repo.sharedpath):\\n                 # truncate name relative to the repository (.hg)\\n                 path = path[len(repo.sharedpath) + 1:]\\n             if repo._currentlock(repo._lockref) is None:\\n                 repo.ui.develwarn('write with no lock: \\\"%s\\\"' % path,\\n                                   stacklevel=3)\\n             return ret\\n         return checksvfs\\n \\n     def close(self):\\n         self._writecaches()\\n \\n+    def addvisibilityexceptions(self, exceptions):\\n+        # should be called on a filtered repository\\n+        pass\\n+\\n+    def getvisibilityexceptions(self):\\n+        # should be called on a filtered repository\\n+        return set()\\n+\\n     def _loadextensions(self):\\n         extensions.loadall(self.ui)\\n \\n     def _writecaches(self):\\n         if self._revbranchcache:\\n             self._revbranchcache.write()\\n \\n     def _restrictcapabilities(self, caps):\\n         if self.ui.configbool('experimental', 'bundle2-advertise'):\\n             caps = set(caps)\\n             capsblob = bundle2.encodecaps(bundle2.getrepocaps(self))\\n             caps.add('bundle2=' + urlreq.quote(capsblob))\\n         return caps\\n \\n     def _applyopenerreqs(self):\\n         self.svfs.options = dict((r, 1) for r in self.requirements\\n                                            if r in self.openerreqs)\\n         # experimental config: format.chunkcachesize\\n         chunkcachesize = self.ui.configint('format', 'chunkcachesize')\\n         if chunkcachesize is not None:\\n             self.svfs.options['chunkcachesize'] = chunkcachesize\\n         # experimental config: format.maxchainlen\\n         maxchainlen = self.ui.configint('format', 'maxchainlen')\\n         if maxchainlen is not None:\\n             self.svfs.options['maxchainlen'] = maxchainlen\\n         # experimental config: format.manifestcachesize\\n         manifestcachesize = self.ui.configint('format', 'manifestcachesize')\\n         if manifestcachesize is not None:\\n             self.svfs.options['manifestcachesize'] = manifestcachesize\\n         # experimental config: format.aggressivemergedeltas\\n         aggressivemergedeltas = self.ui.configbool('format',\\n                                                    'aggressivemergedeltas')\\n         self.svfs.options['aggressivemergedeltas'] = aggressivemergedeltas\\n         self.svfs.options['lazydeltabase'] = not scmutil.gddeltaconfig(self.ui)\\n         chainspan = self.ui.configbytes('experimental', 'maxdeltachainspan')\\n         if 0 \\u003c= chainspan:\\n             self.svfs.options['maxdeltachainspan'] = chainspan\\n         mmapindexthreshold = self.ui.configbytes('experimental',\\n                                                  'mmapindexthreshold')\\n         if mmapindexthreshold is not None:\\n             self.svfs.options['mmapindexthreshold'] = mmapindexthreshold\\n         withsparseread = self.ui.configbool('experimental', 'sparse-read')\\n         srdensitythres = float(self.ui.config('experimental',\\n                                               'sparse-read.density-threshold'))\\n         srmingapsize = self.ui.configbytes('experimental',\\n                                            'sparse-read.min-gap-size')\\n         self.svfs.options['with-sparse-read'] = withsparseread\\n         self.svfs.options['sparse-read-density-threshold'] = srdensitythres\\n         self.svfs.options['sparse-read-min-gap-size'] = srmingapsize\\n \\n         for r in self.requirements:\\n             if r.startswith('exp-compression-'):\\n                 self.svfs.options['compengine'] = r[len('exp-compression-'):]\\n \\n         # TODO move \\\"revlogv2\\\" to openerreqs once finalized.\\n         if REVLOGV2_REQUIREMENT in self.requirements:\\n             self.svfs.options['revlogv2'] = True\\n \\n     def _writerequirements(self):\\n         scmutil.writerequires(self.vfs, self.requirements)\\n \\n     def _checknested(self, path):\\n         \\\"\\\"\\\"Determine if path is a legal nested repository.\\\"\\\"\\\"\\n         if not path.startswith(self.root):\\n             return False\\n         subpath = path[len(self.root) + 1:]\\n         normsubpath = util.pconvert(subpath)\\n \\n         # XXX: Checking against the current working copy is wrong in\\n         # the sense that it can reject things like\\n         #\\n         #   $ hg cat -r 10 sub\\/x.txt\\n         #\\n         # if sub\\/ is no longer a subrepository in the working copy\\n         # parent revision.\\n         #\\n         # However, it can of course also allow things that would have\\n         # been rejected before, such as the above cat command if sub\\/\\n         # is a subrepository now, but was a normal directory before.\\n         # The old path auditor would have rejected by mistake since it\\n         # panics when it sees sub\\/.hg\\/.\\n         #\\n         # All in all, checking against the working copy seems sensible\\n         # since we want to prevent access to nested repositories on\\n         # the filesystem *now*.\\n         ctx = self[None]\\n         parts = util.splitpath(subpath)\\n         while parts:\\n             prefix = '\\/'.join(parts)\\n             if prefix in ctx.substate:\\n                 if prefix == normsubpath:\\n                     return True\\n                 else:\\n                     sub = ctx.sub(prefix)\\n                     return sub.checknested(subpath[len(prefix) + 1:])\\n             else:\\n                 parts.pop()\\n         return False\\n \\n     def peer(self):\\n         return localpeer(self) # not cached to avoid reference cycle\\n \\n     def unfiltered(self):\\n         \\\"\\\"\\\"Return unfiltered version of the repository\\n \\n         Intended to be overwritten by filtered repo.\\\"\\\"\\\"\\n         return self\\n \\n     def filtered(self, name):\\n         \\\"\\\"\\\"Return a filtered version of a repository\\\"\\\"\\\"\\n         # Python \\u003c3.4 easily leaks types via __mro__. See\\n         # https:\\/\\/bugs.python.org\\/issue17950. We cache dynamically\\n         # created types so this method doesn't leak on every\\n         # invocation.\\n \\n         key = self.unfiltered().__class__\\n         if key not in self._filteredrepotypes:\\n             # Build a new type with the repoview mixin and the base\\n             # class of this repo. Give it a name containing the\\n             # filter name to aid debugging.\\n             bases = (repoview.repoview, key)\\n             cls = type(r'%sfilteredrepo' % name, bases, {})\\n             self._filteredrepotypes[key] = cls\\n \\n         return self._filteredrepotypes[key](self, name)\\n \\n     @repofilecache('bookmarks', 'bookmarks.current')\\n     def _bookmarks(self):\\n         return bookmarks.bmstore(self)\\n \\n     @property\\n     def _activebookmark(self):\\n         return self._bookmarks.active\\n \\n     # _phaserevs and _phasesets depend on changelog. what we need is to\\n     # call _phasecache.invalidate() if '00changelog.i' was changed, but it\\n     # can't be easily expressed in filecache mechanism.\\n     @storecache('phaseroots', '00changelog.i')\\n     def _phasecache(self):\\n         return phases.phasecache(self, self._phasedefaults)\\n \\n     @storecache('obsstore')\\n     def obsstore(self):\\n         return obsolete.makestore(self.ui, self)\\n \\n     @storecache('00changelog.i')\\n     def changelog(self):\\n         return changelog.changelog(self.svfs,\\n                                    trypending=txnutil.mayhavepending(self.root))\\n \\n     def _constructmanifest(self):\\n         # This is a temporary function while we migrate from manifest to\\n         # manifestlog. It allows bundlerepo and unionrepo to intercept the\\n         # manifest creation.\\n         return manifest.manifestrevlog(self.svfs)\\n \\n     @storecache('00manifest.i')\\n     def manifestlog(self):\\n         return manifest.manifestlog(self.svfs, self)\\n \\n     @repofilecache('dirstate')\\n     def dirstate(self):\\n         sparsematchfn = lambda: sparse.matcher(self)\\n \\n         return dirstate.dirstate(self.vfs, self.ui, self.root,\\n                                  self._dirstatevalidate, sparsematchfn)\\n \\n     def _dirstatevalidate(self, node):\\n         try:\\n             self.changelog.rev(node)\\n             return node\\n         except error.LookupError:\\n             if not self._dirstatevalidatewarned:\\n                 self._dirstatevalidatewarned = True\\n                 self.ui.warn(_(\\\"warning: ignoring unknown\\\"\\n                                \\\" working parent %s!\\\\n\\\") % short(node))\\n             return nullid\\n \\n     def __getitem__(self, changeid):\\n         if changeid is None:\\n             return context.workingctx(self)\\n         if isinstance(changeid, slice):\\n             # wdirrev isn't contiguous so the slice shouldn't include it\\n             return [context.changectx(self, i)\\n                     for i in xrange(*changeid.indices(len(self)))\\n                     if i not in self.changelog.filteredrevs]\\n         try:\\n             return context.changectx(self, changeid)\\n         except error.WdirUnsupported:\\n             return context.workingctx(self)\\n \\n     def __contains__(self, changeid):\\n         \\\"\\\"\\\"True if the given changeid exists\\n \\n         error.LookupError is raised if an ambiguous node specified.\\n         \\\"\\\"\\\"\\n         try:\\n             self[changeid]\\n             return True\\n         except error.RepoLookupError:\\n             return False\\n \\n     def __nonzero__(self):\\n         return True\\n \\n     __bool__ = __nonzero__\\n \\n     def __len__(self):\\n         return len(self.changelog)\\n \\n     def __iter__(self):\\n         return iter(self.changelog)\\n \\n     def revs(self, expr, *args):\\n         '''Find revisions matching a revset.\\n \\n         The revset is specified as a string ``expr`` that may contain\\n         %-formatting to escape certain types. See ``revsetlang.formatspec``.\\n \\n         Revset aliases from the configuration are not expanded. To expand\\n         user aliases, consider calling ``scmutil.revrange()`` or\\n         ``repo.anyrevs([expr], user=True)``.\\n \\n         Returns a revset.abstractsmartset, which is a list-like interface\\n         that contains integer revisions.\\n         '''\\n         expr = revsetlang.formatspec(expr, *args)\\n         m = revset.match(None, expr)\\n         return m(self)\\n \\n     def set(self, expr, *args):\\n         '''Find revisions matching a revset and emit changectx instances.\\n \\n         This is a convenience wrapper around ``revs()`` that iterates the\\n         result and is a generator of changectx instances.\\n \\n         Revset aliases from the configuration are not expanded. To expand\\n         user aliases, consider calling ``scmutil.revrange()``.\\n         '''\\n         for r in self.revs(expr, *args):\\n             yield self[r]\\n \\n     def anyrevs(self, specs, user=False, localalias=None):\\n         '''Find revisions matching one of the given revsets.\\n \\n         Revset aliases from the configuration are not expanded by default. To\\n         expand user aliases, specify ``user=True``. To provide some local\\n         definitions overriding user aliases, set ``localalias`` to\\n         ``{name: definitionstring}``.\\n         '''\\n         if user:\\n             m = revset.matchany(self.ui, specs, repo=self,\\n                                 localalias=localalias)\\n         else:\\n             m = revset.matchany(None, specs, localalias=localalias)\\n         return m(self)\\n \\n     def url(self):\\n         return 'file:' + self.root\\n \\n     def hook(self, name, throw=False, **args):\\n         \\\"\\\"\\\"Call a hook, passing this repo instance.\\n \\n         This a convenience method to aid invoking hooks. Extensions likely\\n         won't call this unless they have registered a custom hook or are\\n         replacing code that is expected to call a hook.\\n         \\\"\\\"\\\"\\n         return hook.hook(self.ui, self, name, throw, **args)\\n \\n     @filteredpropertycache\\n     def _tagscache(self):\\n         '''Returns a tagscache object that contains various tags related\\n         caches.'''\\n \\n         # This simplifies its cache management by having one decorated\\n         # function (this one) and the rest simply fetch things from it.\\n         class tagscache(object):\\n             def __init__(self):\\n                 # These two define the set of tags for this repository. tags\\n                 # maps tag name to node; tagtypes maps tag name to 'global' or\\n                 # 'local'. (Global tags are defined by .hgtags across all\\n                 # heads, and local tags are defined in .hg\\/localtags.)\\n                 # They constitute the in-memory cache of tags.\\n                 self.tags = self.tagtypes = None\\n \\n                 self.nodetagscache = self.tagslist = None\\n \\n         cache = tagscache()\\n         cache.tags, cache.tagtypes = self._findtags()\\n \\n         return cache\\n \\n     def tags(self):\\n         '''return a mapping of tag to node'''\\n         t = {}\\n         if self.changelog.filteredrevs:\\n             tags, tt = self._findtags()\\n         else:\\n             tags = self._tagscache.tags\\n         for k, v in tags.iteritems():\\n             try:\\n                 # ignore tags to unknown nodes\\n                 self.changelog.rev(v)\\n                 t[k] = v\\n             except (error.LookupError, ValueError):\\n                 pass\\n         return t\\n \\n     def _findtags(self):\\n         '''Do the hard work of finding tags.  Return a pair of dicts\\n         (tags, tagtypes) where tags maps tag name to node, and tagtypes\\n         maps tag name to a string like \\\\'global\\\\' or \\\\'local\\\\'.\\n         Subclasses or extensions are free to add their own tags, but\\n         should be aware that the returned dicts will be retained for the\\n         duration of the localrepo object.'''\\n \\n         # XXX what tagtype should subclasses\\/extensions use?  Currently\\n         # mq and bookmarks add tags, but do not set the tagtype at all.\\n         # Should each extension invent its own tag type?  Should there\\n         # be one tagtype for all such \\\"virtual\\\" tags?  Or is the status\\n         # quo fine?\\n \\n \\n         # map tag name to (node, hist)\\n         alltags = tagsmod.findglobaltags(self.ui, self)\\n         # map tag name to tag type\\n         tagtypes = dict((tag, 'global') for tag in alltags)\\n \\n         tagsmod.readlocaltags(self.ui, self, alltags, tagtypes)\\n \\n         # Build the return dicts.  Have to re-encode tag names because\\n         # the tags module always uses UTF-8 (in order not to lose info\\n         # writing to the cache), but the rest of Mercurial wants them in\\n         # local encoding.\\n         tags = {}\\n         for (name, (node, hist)) in alltags.iteritems():\\n             if node != nullid:\\n                 tags[encoding.tolocal(name)] = node\\n         tags['tip'] = self.changelog.tip()\\n         tagtypes = dict([(encoding.tolocal(name), value)\\n                          for (name, value) in tagtypes.iteritems()])\\n         return (tags, tagtypes)\\n \\n     def tagtype(self, tagname):\\n         '''\\n         return the type of the given tag. result can be:\\n \\n         'local'  : a local tag\\n         'global' : a global tag\\n         None     : tag does not exist\\n         '''\\n \\n         return self._tagscache.tagtypes.get(tagname)\\n \\n     def tagslist(self):\\n         '''return a list of tags ordered by revision'''\\n         if not self._tagscache.tagslist:\\n             l = []\\n             for t, n in self.tags().iteritems():\\n                 l.append((self.changelog.rev(n), t, n))\\n             self._tagscache.tagslist = [(t, n) for r, t, n in sorted(l)]\\n \\n         return self._tagscache.tagslist\\n \\n     def nodetags(self, node):\\n         '''return the tags associated with a node'''\\n         if not self._tagscache.nodetagscache:\\n             nodetagscache = {}\\n             for t, n in self._tagscache.tags.iteritems():\\n                 nodetagscache.setdefault(n, []).append(t)\\n             for tags in nodetagscache.itervalues():\\n                 tags.sort()\\n             self._tagscache.nodetagscache = nodetagscache\\n         return self._tagscache.nodetagscache.get(node, [])\\n \\n     def nodebookmarks(self, node):\\n         \\\"\\\"\\\"return the list of bookmarks pointing to the specified node\\\"\\\"\\\"\\n         marks = []\\n         for bookmark, n in self._bookmarks.iteritems():\\n             if n == node:\\n                 marks.append(bookmark)\\n         return sorted(marks)\\n \\n     def branchmap(self):\\n         '''returns a dictionary {branch: [branchheads]} with branchheads\\n         ordered by increasing revision number'''\\n         branchmap.updatecache(self)\\n         return self._branchcaches[self.filtername]\\n \\n     @unfilteredmethod\\n     def revbranchcache(self):\\n         if not self._revbranchcache:\\n             self._revbranchcache = branchmap.revbranchcache(self.unfiltered())\\n         return self._revbranchcache\\n \\n     def branchtip(self, branch, ignoremissing=False):\\n         '''return the tip node for a given branch\\n \\n         If ignoremissing is True, then this method will not raise an error.\\n         This is helpful for callers that only expect None for a missing branch\\n         (e.g. namespace).\\n \\n         '''\\n         try:\\n             return self.branchmap().branchtip(branch)\\n         except KeyError:\\n             if not ignoremissing:\\n                 raise error.RepoLookupError(_(\\\"unknown branch '%s'\\\") % branch)\\n             else:\\n                 pass\\n \\n     def lookup(self, key):\\n         return self[key].node()\\n \\n     def lookupbranch(self, key, remote=None):\\n         repo = remote or self\\n         if key in repo.branchmap():\\n             return key\\n \\n         repo = (remote and remote.local()) and remote or self\\n         return repo[key].branch()\\n \\n     def known(self, nodes):\\n         cl = self.changelog\\n         nm = cl.nodemap\\n         filtered = cl.filteredrevs\\n         result = []\\n         for n in nodes:\\n             r = nm.get(n)\\n             resp = not (r is None or r in filtered)\\n             result.append(resp)\\n         return result\\n \\n     def local(self):\\n         return self\\n \\n     def publishing(self):\\n         # it's safe (and desirable) to trust the publish flag unconditionally\\n         # so that we don't finalize changes shared between users via ssh or nfs\\n         return self.ui.configbool('phases', 'publish', untrusted=True)\\n \\n     def cancopy(self):\\n         # so statichttprepo's override of local() works\\n         if not self.local():\\n             return False\\n         if not self.publishing():\\n             return True\\n         # if publishing we can't copy if there is filtered content\\n         return not self.filtered('visible').changelog.filteredrevs\\n \\n     def shared(self):\\n         '''the type of shared repository (None if not shared)'''\\n         if self.sharedpath != self.path:\\n             return 'store'\\n         return None\\n \\n     def wjoin(self, f, *insidef):\\n         return self.vfs.reljoin(self.root, f, *insidef)\\n \\n     def file(self, f):\\n         if f[0] == '\\/':\\n             f = f[1:]\\n         return filelog.filelog(self.svfs, f)\\n \\n     def changectx(self, changeid):\\n         return self[changeid]\\n \\n     def setparents(self, p1, p2=nullid):\\n         with self.dirstate.parentchange():\\n             copies = self.dirstate.setparents(p1, p2)\\n             pctx = self[p1]\\n             if copies:\\n                 # Adjust copy records, the dirstate cannot do it, it\\n                 # requires access to parents manifests. Preserve them\\n                 # only for entries added to first parent.\\n                 for f in copies:\\n                     if f not in pctx and copies[f] in pctx:\\n                         self.dirstate.copy(copies[f], f)\\n             if p2 == nullid:\\n                 for f, s in sorted(self.dirstate.copies().items()):\\n                     if f not in pctx and s not in pctx:\\n                         self.dirstate.copy(None, f)\\n \\n     def filectx(self, path, changeid=None, fileid=None):\\n         \\\"\\\"\\\"changeid can be a changeset revision, node, or tag.\\n            fileid can be a file revision or node.\\\"\\\"\\\"\\n         return context.filectx(self, path, changeid, fileid)\\n \\n     def getcwd(self):\\n         return self.dirstate.getcwd()\\n \\n     def pathto(self, f, cwd=None):\\n         return self.dirstate.pathto(f, cwd)\\n \\n     def _loadfilter(self, filter):\\n         if filter not in self.filterpats:\\n             l = []\\n             for pat, cmd in self.ui.configitems(filter):\\n                 if cmd == '!':\\n                     continue\\n                 mf = matchmod.match(self.root, '', [pat])\\n                 fn = None\\n                 params = cmd\\n                 for name, filterfn in self._datafilters.iteritems():\\n                     if cmd.startswith(name):\\n                         fn = filterfn\\n                         params = cmd[len(name):].lstrip()\\n                         break\\n                 if not fn:\\n                     fn = lambda s, c, **kwargs: util.filter(s, c)\\n                 # Wrap old filters not supporting keyword arguments\\n                 if not inspect.getargspec(fn)[2]:\\n                     oldfn = fn\\n                     fn = lambda s, c, **kwargs: oldfn(s, c)\\n                 l.append((mf, fn, params))\\n             self.filterpats[filter] = l\\n         return self.filterpats[filter]\\n \\n     def _filter(self, filterpats, filename, data):\\n         for mf, fn, cmd in filterpats:\\n             if mf(filename):\\n                 self.ui.debug(\\\"filtering %s through %s\\\\n\\\" % (filename, cmd))\\n                 data = fn(data, cmd, ui=self.ui, repo=self, filename=filename)\\n                 break\\n \\n         return data\\n \\n     @unfilteredpropertycache\\n     def _encodefilterpats(self):\\n         return self._loadfilter('encode')\\n \\n     @unfilteredpropertycache\\n     def _decodefilterpats(self):\\n         return self._loadfilter('decode')\\n \\n     def adddatafilter(self, name, filter):\\n         self._datafilters[name] = filter\\n \\n     def wread(self, filename):\\n         if self.wvfs.islink(filename):\\n             data = self.wvfs.readlink(filename)\\n         else:\\n             data = self.wvfs.read(filename)\\n         return self._filter(self._encodefilterpats, filename, data)\\n \\n     def wwrite(self, filename, data, flags, backgroundclose=False):\\n         \\\"\\\"\\\"write ``data`` into ``filename`` in the working directory\\n \\n         This returns length of written (maybe decoded) data.\\n         \\\"\\\"\\\"\\n         data = self._filter(self._decodefilterpats, filename, data)\\n         if 'l' in flags:\\n             self.wvfs.symlink(data, filename)\\n         else:\\n             self.wvfs.write(filename, data, backgroundclose=backgroundclose)\\n             if 'x' in flags:\\n                 self.wvfs.setflags(filename, False, True)\\n         return len(data)\\n \\n     def wwritedata(self, filename, data):\\n         return self._filter(self._decodefilterpats, filename, data)\\n \\n     def currenttransaction(self):\\n         \\\"\\\"\\\"return the current transaction or None if non exists\\\"\\\"\\\"\\n         if self._transref:\\n             tr = self._transref()\\n         else:\\n             tr = None\\n \\n         if tr and tr.running():\\n             return tr\\n         return None\\n \\n     def transaction(self, desc, report=None):\\n         if (self.ui.configbool('devel', 'all-warnings')\\n                 or self.ui.configbool('devel', 'check-locks')):\\n             if self._currentlock(self._lockref) is None:\\n                 raise error.ProgrammingError('transaction requires locking')\\n         tr = self.currenttransaction()\\n         if tr is not None:\\n             scmutil.registersummarycallback(self, tr, desc)\\n             return tr.nest()\\n \\n         # abort here if the journal already exists\\n         if self.svfs.exists(\\\"journal\\\"):\\n             raise error.RepoError(\\n                 _(\\\"abandoned transaction found\\\"),\\n                 hint=_(\\\"run 'hg recover' to clean up transaction\\\"))\\n \\n         idbase = \\\"%.40f#%f\\\" % (random.random(), time.time())\\n         ha = hex(hashlib.sha1(idbase).digest())\\n         txnid = 'TXN:' + ha\\n         self.hook('pretxnopen', throw=True, txnname=desc, txnid=txnid)\\n \\n         self._writejournal(desc)\\n         renames = [(vfs, x, undoname(x)) for vfs, x in self._journalfiles()]\\n         if report:\\n             rp = report\\n         else:\\n             rp = self.ui.warn\\n         vfsmap = {'plain': self.vfs} # root of .hg\\/\\n         # we must avoid cyclic reference between repo and transaction.\\n         reporef = weakref.ref(self)\\n         # Code to track tag movement\\n         #\\n         # Since tags are all handled as file content, it is actually quite hard\\n         # to track these movement from a code perspective. So we fallback to a\\n         # tracking at the repository level. One could envision to track changes\\n         # to the '.hgtags' file through changegroup apply but that fails to\\n         # cope with case where transaction expose new heads without changegroup\\n         # being involved (eg: phase movement).\\n         #\\n         # For now, We gate the feature behind a flag since this likely comes\\n         # with performance impacts. The current code run more often than needed\\n         # and do not use caches as much as it could.  The current focus is on\\n         # the behavior of the feature so we disable it by default. The flag\\n         # will be removed when we are happy with the performance impact.\\n         #\\n         # Once this feature is no longer experimental move the following\\n         # documentation to the appropriate help section:\\n         #\\n         # The ``HG_TAG_MOVED`` variable will be set if the transaction touched\\n         # tags (new or changed or deleted tags). In addition the details of\\n         # these changes are made available in a file at:\\n         #     ``REPOROOT\\/.hg\\/changes\\/tags.changes``.\\n         # Make sure you check for HG_TAG_MOVED before reading that file as it\\n         # might exist from a previous transaction even if no tag were touched\\n         # in this one. Changes are recorded in a line base format::\\n         #\\n         #     \\u003caction\\u003e \\u003chex-node\\u003e \\u003ctag-name\\u003e\\\\n\\n         #\\n         # Actions are defined as follow:\\n         #   \\\"-R\\\": tag is removed,\\n         #   \\\"+A\\\": tag is added,\\n         #   \\\"-M\\\": tag is moved (old value),\\n         #   \\\"+M\\\": tag is moved (new value),\\n         tracktags = lambda x: None\\n         # experimental config: experimental.hook-track-tags\\n         shouldtracktags = self.ui.configbool('experimental', 'hook-track-tags')\\n         if desc != 'strip' and shouldtracktags:\\n             oldheads = self.changelog.headrevs()\\n             def tracktags(tr2):\\n                 repo = reporef()\\n                 oldfnodes = tagsmod.fnoderevs(repo.ui, repo, oldheads)\\n                 newheads = repo.changelog.headrevs()\\n                 newfnodes = tagsmod.fnoderevs(repo.ui, repo, newheads)\\n                 # notes: we compare lists here.\\n                 # As we do it only once buiding set would not be cheaper\\n                 changes = tagsmod.difftags(repo.ui, repo, oldfnodes, newfnodes)\\n                 if changes:\\n                     tr2.hookargs['tag_moved'] = '1'\\n                     with repo.vfs('changes\\/tags.changes', 'w',\\n                                   atomictemp=True) as changesfile:\\n                         # note: we do not register the file to the transaction\\n                         # because we needs it to still exist on the transaction\\n                         # is close (for txnclose hooks)\\n                         tagsmod.writediff(changesfile, changes)\\n         def validate(tr2):\\n             \\\"\\\"\\\"will run pre-closing hooks\\\"\\\"\\\"\\n             # XXX the transaction API is a bit lacking here so we take a hacky\\n             # path for now\\n             #\\n             # We cannot add this as a \\\"pending\\\" hooks since the 'tr.hookargs'\\n             # dict is copied before these run. In addition we needs the data\\n             # available to in memory hooks too.\\n             #\\n             # Moreover, we also need to make sure this runs before txnclose\\n             # hooks and there is no \\\"pending\\\" mechanism that would execute\\n             # logic only if hooks are about to run.\\n             #\\n             # Fixing this limitation of the transaction is also needed to track\\n             # other families of changes (bookmarks, phases, obsolescence).\\n             #\\n             # This will have to be fixed before we remove the experimental\\n             # gating.\\n             tracktags(tr2)\\n             repo = reporef()\\n             if repo.ui.configbool('experimental', 'single-head-per-branch'):\\n                 scmutil.enforcesinglehead(repo, tr2, desc)\\n             if hook.hashook(repo.ui, 'pretxnclose-bookmark'):\\n                 for name, (old, new) in sorted(tr.changes['bookmarks'].items()):\\n                     args = tr.hookargs.copy()\\n                     args.update(bookmarks.preparehookargs(name, old, new))\\n                     repo.hook('pretxnclose-bookmark', throw=True,\\n                               txnname=desc,\\n                               **pycompat.strkwargs(args))\\n             if hook.hashook(repo.ui, 'pretxnclose-phase'):\\n                 cl = repo.unfiltered().changelog\\n                 for rev, (old, new) in tr.changes['phases'].items():\\n                     args = tr.hookargs.copy()\\n                     node = hex(cl.node(rev))\\n                     args.update(phases.preparehookargs(node, old, new))\\n                     repo.hook('pretxnclose-phase', throw=True, txnname=desc,\\n                               **pycompat.strkwargs(args))\\n \\n             repo.hook('pretxnclose', throw=True,\\n                       txnname=desc, **pycompat.strkwargs(tr.hookargs))\\n         def releasefn(tr, success):\\n             repo = reporef()\\n             if success:\\n                 # this should be explicitly invoked here, because\\n                 # in-memory changes aren't written out at closing\\n                 # transaction, if tr.addfilegenerator (via\\n                 # dirstate.write or so) isn't invoked while\\n                 # transaction running\\n                 repo.dirstate.write(None)\\n             else:\\n                 # discard all changes (including ones already written\\n                 # out) in this transaction\\n                 repo.dirstate.restorebackup(None, 'journal.dirstate')\\n \\n                 repo.invalidate(clearfilecache=True)\\n \\n         tr = transaction.transaction(rp, self.svfs, vfsmap,\\n                                      \\\"journal\\\",\\n                                      \\\"undo\\\",\\n                                      aftertrans(renames),\\n                                      self.store.createmode,\\n                                      validator=validate,\\n                                      releasefn=releasefn,\\n                                      checkambigfiles=_cachedfiles)\\n         tr.changes['revs'] = set()\\n         tr.changes['obsmarkers'] = set()\\n         tr.changes['phases'] = {}\\n         tr.changes['bookmarks'] = {}\\n \\n         tr.hookargs['txnid'] = txnid\\n         # note: writing the fncache only during finalize mean that the file is\\n         # outdated when running hooks. As fncache is used for streaming clone,\\n         # this is not expected to break anything that happen during the hooks.\\n         tr.addfinalize('flush-fncache', self.store.write)\\n         def txnclosehook(tr2):\\n             \\\"\\\"\\\"To be run if transaction is successful, will schedule a hook run\\n             \\\"\\\"\\\"\\n             # Don't reference tr2 in hook() so we don't hold a reference.\\n             # This reduces memory consumption when there are multiple\\n             # transactions per lock. This can likely go away if issue5045\\n             # fixes the function accumulation.\\n             hookargs = tr2.hookargs\\n \\n             def hookfunc():\\n                 repo = reporef()\\n                 if hook.hashook(repo.ui, 'txnclose-bookmark'):\\n                     bmchanges = sorted(tr.changes['bookmarks'].items())\\n                     for name, (old, new) in bmchanges:\\n                         args = tr.hookargs.copy()\\n                         args.update(bookmarks.preparehookargs(name, old, new))\\n                         repo.hook('txnclose-bookmark', throw=False,\\n                                   txnname=desc, **pycompat.strkwargs(args))\\n \\n                 if hook.hashook(repo.ui, 'txnclose-phase'):\\n                     cl = repo.unfiltered().changelog\\n                     phasemv = sorted(tr.changes['phases'].items())\\n                     for rev, (old, new) in phasemv:\\n                         args = tr.hookargs.copy()\\n                         node = hex(cl.node(rev))\\n                         args.update(phases.preparehookargs(node, old, new))\\n                         repo.hook('txnclose-phase', throw=False, txnname=desc,\\n                                   **pycompat.strkwargs(args))\\n \\n                 repo.hook('txnclose', throw=False, txnname=desc,\\n                           **pycompat.strkwargs(hookargs))\\n             reporef()._afterlock(hookfunc)\\n         tr.addfinalize('txnclose-hook', txnclosehook)\\n         tr.addpostclose('warms-cache', self._buildcacheupdater(tr))\\n         def txnaborthook(tr2):\\n             \\\"\\\"\\\"To be run if transaction is aborted\\n             \\\"\\\"\\\"\\n             reporef().hook('txnabort', throw=False, txnname=desc,\\n                            **tr2.hookargs)\\n         tr.addabort('txnabort-hook', txnaborthook)\\n         # avoid eager cache invalidation. in-memory data should be identical\\n         # to stored data if transaction has no error.\\n         tr.addpostclose('refresh-filecachestats', self._refreshfilecachestats)\\n         self._transref = weakref.ref(tr)\\n         scmutil.registersummarycallback(self, tr, desc)\\n         return tr\\n \\n     def _journalfiles(self):\\n         return ((self.svfs, 'journal'),\\n                 (self.vfs, 'journal.dirstate'),\\n                 (self.vfs, 'journal.branch'),\\n                 (self.vfs, 'journal.desc'),\\n                 (self.vfs, 'journal.bookmarks'),\\n                 (self.svfs, 'journal.phaseroots'))\\n \\n     def undofiles(self):\\n         return [(vfs, undoname(x)) for vfs, x in self._journalfiles()]\\n \\n     @unfilteredmethod\\n     def _writejournal(self, desc):\\n         self.dirstate.savebackup(None, 'journal.dirstate')\\n         self.vfs.write(\\\"journal.branch\\\",\\n                           encoding.fromlocal(self.dirstate.branch()))\\n         self.vfs.write(\\\"journal.desc\\\",\\n                           \\\"%d\\\\n%s\\\\n\\\" % (len(self), desc))\\n         self.vfs.write(\\\"journal.bookmarks\\\",\\n                           self.vfs.tryread(\\\"bookmarks\\\"))\\n         self.svfs.write(\\\"journal.phaseroots\\\",\\n                            self.svfs.tryread(\\\"phaseroots\\\"))\\n \\n     def recover(self):\\n         with self.lock():\\n             if self.svfs.exists(\\\"journal\\\"):\\n                 self.ui.status(_(\\\"rolling back interrupted transaction\\\\n\\\"))\\n                 vfsmap = {'': self.svfs,\\n                           'plain': self.vfs,}\\n                 transaction.rollback(self.svfs, vfsmap, \\\"journal\\\",\\n                                      self.ui.warn,\\n                                      checkambigfiles=_cachedfiles)\\n                 self.invalidate()\\n                 return True\\n             else:\\n                 self.ui.warn(_(\\\"no interrupted transaction available\\\\n\\\"))\\n                 return False\\n \\n     def rollback(self, dryrun=False, force=False):\\n         wlock = lock = dsguard = None\\n         try:\\n             wlock = self.wlock()\\n             lock = self.lock()\\n             if self.svfs.exists(\\\"undo\\\"):\\n                 dsguard = dirstateguard.dirstateguard(self, 'rollback')\\n \\n                 return self._rollback(dryrun, force, dsguard)\\n             else:\\n                 self.ui.warn(_(\\\"no rollback information available\\\\n\\\"))\\n                 return 1\\n         finally:\\n             release(dsguard, lock, wlock)\\n \\n     @unfilteredmethod # Until we get smarter cache management\\n     def _rollback(self, dryrun, force, dsguard):\\n         ui = self.ui\\n         try:\\n             args = self.vfs.read('undo.desc').splitlines()\\n             (oldlen, desc, detail) = (int(args[0]), args[1], None)\\n             if len(args) \\u003e= 3:\\n                 detail = args[2]\\n             oldtip = oldlen - 1\\n \\n             if detail and ui.verbose:\\n                 msg = (_('repository tip rolled back to revision %d'\\n                          ' (undo %s: %s)\\\\n')\\n                        % (oldtip, desc, detail))\\n             else:\\n                 msg = (_('repository tip rolled back to revision %d'\\n                          ' (undo %s)\\\\n')\\n                        % (oldtip, desc))\\n         except IOError:\\n             msg = _('rolling back unknown transaction\\\\n')\\n             desc = None\\n \\n         if not force and self['.'] != self['tip'] and desc == 'commit':\\n             raise error.Abort(\\n                 _('rollback of last commit while not checked out '\\n                   'may lose data'), hint=_('use -f to force'))\\n \\n         ui.status(msg)\\n         if dryrun:\\n             return 0\\n \\n         parents = self.dirstate.parents()\\n         self.destroying()\\n         vfsmap = {'plain': self.vfs, '': self.svfs}\\n         transaction.rollback(self.svfs, vfsmap, 'undo', ui.warn,\\n                              checkambigfiles=_cachedfiles)\\n         if self.vfs.exists('undo.bookmarks'):\\n             self.vfs.rename('undo.bookmarks', 'bookmarks', checkambig=True)\\n         if self.svfs.exists('undo.phaseroots'):\\n             self.svfs.rename('undo.phaseroots', 'phaseroots', checkambig=True)\\n         self.invalidate()\\n \\n         parentgone = (parents[0] not in self.changelog.nodemap or\\n                       parents[1] not in self.changelog.nodemap)\\n         if parentgone:\\n             # prevent dirstateguard from overwriting already restored one\\n             dsguard.close()\\n \\n             self.dirstate.restorebackup(None, 'undo.dirstate')\\n             try:\\n                 branch = self.vfs.read('undo.branch')\\n                 self.dirstate.setbranch(encoding.tolocal(branch))\\n             except IOError:\\n                 ui.warn(_('named branch could not be reset: '\\n                           'current branch is still \\\\'%s\\\\'\\\\n')\\n                         % self.dirstate.branch())\\n \\n             parents = tuple([p.rev() for p in self[None].parents()])\\n             if len(parents) \\u003e 1:\\n                 ui.status(_('working directory now based on '\\n                             'revisions %d and %d\\\\n') % parents)\\n             else:\\n                 ui.status(_('working directory now based on '\\n                             'revision %d\\\\n') % parents)\\n             mergemod.mergestate.clean(self, self['.'].node())\\n \\n         # TODO: if we know which new heads may result from this rollback, pass\\n         # them to destroy(), which will prevent the branchhead cache from being\\n         # invalidated.\\n         self.destroyed()\\n         return 0\\n \\n     def _buildcacheupdater(self, newtransaction):\\n         \\\"\\\"\\\"called during transaction to build the callback updating cache\\n \\n         Lives on the repository to help extension who might want to augment\\n         this logic. For this purpose, the created transaction is passed to the\\n         method.\\n         \\\"\\\"\\\"\\n         # we must avoid cyclic reference between repo and transaction.\\n         reporef = weakref.ref(self)\\n         def updater(tr):\\n             repo = reporef()\\n             repo.updatecaches(tr)\\n         return updater\\n \\n     @unfilteredmethod\\n     def updatecaches(self, tr=None):\\n         \\\"\\\"\\\"warm appropriate caches\\n \\n         If this function is called after a transaction closed. The transaction\\n         will be available in the 'tr' argument. This can be used to selectively\\n         update caches relevant to the changes in that transaction.\\n         \\\"\\\"\\\"\\n         if tr is not None and tr.hookargs.get('source') == 'strip':\\n             # During strip, many caches are invalid but\\n             # later call to `destroyed` will refresh them.\\n             return\\n \\n         if tr is None or tr.changes['revs']:\\n             # updating the unfiltered branchmap should refresh all the others,\\n             self.ui.debug('updating the branch cache\\\\n')\\n             branchmap.updatecache(self.filtered('served'))\\n \\n     def invalidatecaches(self):\\n \\n         if '_tagscache' in vars(self):\\n             # can't use delattr on proxy\\n             del self.__dict__['_tagscache']\\n \\n         self.unfiltered()._branchcaches.clear()\\n         self.invalidatevolatilesets()\\n         self._sparsesignaturecache.clear()\\n \\n     def invalidatevolatilesets(self):\\n         self.filteredrevcache.clear()\\n         obsolete.clearobscaches(self)\\n \\n     def invalidatedirstate(self):\\n         '''Invalidates the dirstate, causing the next call to dirstate\\n         to check if it was modified since the last time it was read,\\n         rereading it if it has.\\n \\n         This is different to dirstate.invalidate() that it doesn't always\\n         rereads the dirstate. Use dirstate.invalidate() if you want to\\n         explicitly read the dirstate again (i.e. restoring it to a previous\\n         known good state).'''\\n         if hasunfilteredcache(self, 'dirstate'):\\n             for k in self.dirstate._filecache:\\n                 try:\\n                     delattr(self.dirstate, k)\\n                 except AttributeError:\\n                     pass\\n             delattr(self.unfiltered(), 'dirstate')\\n \\n     def invalidate(self, clearfilecache=False):\\n         '''Invalidates both store and non-store parts other than dirstate\\n \\n         If a transaction is running, invalidation of store is omitted,\\n         because discarding in-memory changes might cause inconsistency\\n         (e.g. incomplete fncache causes unintentional failure, but\\n         redundant one doesn't).\\n         '''\\n         unfiltered = self.unfiltered() # all file caches are stored unfiltered\\n         for k in list(self._filecache.keys()):\\n             # dirstate is invalidated separately in invalidatedirstate()\\n             if k == 'dirstate':\\n                 continue\\n             if (k == 'changelog' and\\n                 self.currenttransaction() and\\n                 self.changelog._delayed):\\n                 # The changelog object may store unwritten revisions. We don't\\n                 # want to lose them.\\n                 # TODO: Solve the problem instead of working around it.\\n                 continue\\n \\n             if clearfilecache:\\n                 del self._filecache[k]\\n             try:\\n                 delattr(unfiltered, k)\\n             except AttributeError:\\n                 pass\\n         self.invalidatecaches()\\n         if not self.currenttransaction():\\n             # TODO: Changing contents of store outside transaction\\n             # causes inconsistency. We should make in-memory store\\n             # changes detectable, and abort if changed.\\n             self.store.invalidatecaches()\\n \\n     def invalidateall(self):\\n         '''Fully invalidates both store and non-store parts, causing the\\n         subsequent operation to reread any outside changes.'''\\n         # extension should hook this to invalidate its caches\\n         self.invalidate()\\n         self.invalidatedirstate()\\n \\n     @unfilteredmethod\\n     def _refreshfilecachestats(self, tr):\\n         \\\"\\\"\\\"Reload stats of cached files so that they are flagged as valid\\\"\\\"\\\"\\n         for k, ce in self._filecache.items():\\n             if k == 'dirstate' or k not in self.__dict__:\\n                 continue\\n             ce.refresh()\\n \\n     def _lock(self, vfs, lockname, wait, releasefn, acquirefn, desc,\\n               inheritchecker=None, parentenvvar=None):\\n         parentlock = None\\n         # the contents of parentenvvar are used by the underlying lock to\\n         # determine whether it can be inherited\\n         if parentenvvar is not None:\\n             parentlock = encoding.environ.get(parentenvvar)\\n         try:\\n             l = lockmod.lock(vfs, lockname, 0, releasefn=releasefn,\\n                              acquirefn=acquirefn, desc=desc,\\n                              inheritchecker=inheritchecker,\\n                              parentlock=parentlock)\\n         except error.LockHeld as inst:\\n             if not wait:\\n                 raise\\n             # show more details for new-style locks\\n             if ':' in inst.locker:\\n                 host, pid = inst.locker.split(\\\":\\\", 1)\\n                 self.ui.warn(\\n                     _(\\\"waiting for lock on %s held by process %r \\\"\\n                       \\\"on host %r\\\\n\\\") % (desc, pid, host))\\n             else:\\n                 self.ui.warn(_(\\\"waiting for lock on %s held by %r\\\\n\\\") %\\n                              (desc, inst.locker))\\n             # default to 600 seconds timeout\\n             l = lockmod.lock(vfs, lockname,\\n                              int(self.ui.config(\\\"ui\\\", \\\"timeout\\\")),\\n                              releasefn=releasefn, acquirefn=acquirefn,\\n                              desc=desc)\\n             self.ui.warn(_(\\\"got lock after %s seconds\\\\n\\\") % l.delay)\\n         return l\\n \\n     def _afterlock(self, callback):\\n         \\\"\\\"\\\"add a callback to be run when the repository is fully unlocked\\n \\n         The callback will be executed when the outermost lock is released\\n         (with wlock being higher level than 'lock').\\\"\\\"\\\"\\n         for ref in (self._wlockref, self._lockref):\\n             l = ref and ref()\\n             if l and l.held:\\n                 l.postrelease.append(callback)\\n                 break\\n         else: # no lock have been found.\\n             callback()\\n \\n     def lock(self, wait=True):\\n         '''Lock the repository store (.hg\\/store) and return a weak reference\\n         to the lock. Use this before modifying the store (e.g. committing or\\n         stripping). If you are opening a transaction, get a lock as well.)\\n \\n         If both 'lock' and 'wlock' must be acquired, ensure you always acquires\\n         'wlock' first to avoid a dead-lock hazard.'''\\n         l = self._currentlock(self._lockref)\\n         if l is not None:\\n             l.lock()\\n             return l\\n \\n         l = self._lock(self.svfs, \\\"lock\\\", wait, None,\\n                        self.invalidate, _('repository %s') % self.origroot)\\n         self._lockref = weakref.ref(l)\\n         return l\\n \\n     def _wlockchecktransaction(self):\\n         if self.currenttransaction() is not None:\\n             raise error.LockInheritanceContractViolation(\\n                 'wlock cannot be inherited in the middle of a transaction')\\n \\n     def wlock(self, wait=True):\\n         '''Lock the non-store parts of the repository (everything under\\n         .hg except .hg\\/store) and return a weak reference to the lock.\\n \\n         Use this before modifying files in .hg.\\n \\n         If both 'lock' and 'wlock' must be acquired, ensure you always acquires\\n         'wlock' first to avoid a dead-lock hazard.'''\\n         l = self._wlockref and self._wlockref()\\n         if l is not None and l.held:\\n             l.lock()\\n             return l\\n \\n         # We do not need to check for non-waiting lock acquisition.  Such\\n         # acquisition would not cause dead-lock as they would just fail.\\n         if wait and (self.ui.configbool('devel', 'all-warnings')\\n                      or self.ui.configbool('devel', 'check-locks')):\\n             if self._currentlock(self._lockref) is not None:\\n                 self.ui.develwarn('\\\"wlock\\\" acquired after \\\"lock\\\"')\\n \\n         def unlock():\\n             if self.dirstate.pendingparentchange():\\n                 self.dirstate.invalidate()\\n             else:\\n                 self.dirstate.write(None)\\n \\n             self._filecache['dirstate'].refresh()\\n \\n         l = self._lock(self.vfs, \\\"wlock\\\", wait, unlock,\\n                        self.invalidatedirstate, _('working directory of %s') %\\n                        self.origroot,\\n                        inheritchecker=self._wlockchecktransaction,\\n                        parentenvvar='HG_WLOCK_LOCKER')\\n         self._wlockref = weakref.ref(l)\\n         return l\\n \\n     def _currentlock(self, lockref):\\n         \\\"\\\"\\\"Returns the lock if it's held, or None if it's not.\\\"\\\"\\\"\\n         if lockref is None:\\n             return None\\n         l = lockref()\\n         if l is None or not l.held:\\n             return None\\n         return l\\n \\n     def currentwlock(self):\\n         \\\"\\\"\\\"Returns the wlock if it's held, or None if it's not.\\\"\\\"\\\"\\n         return self._currentlock(self._wlockref)\\n \\n     def _filecommit(self, fctx, manifest1, manifest2, linkrev, tr, changelist):\\n         \\\"\\\"\\\"\\n         commit an individual file as part of a larger transaction\\n         \\\"\\\"\\\"\\n \\n         fname = fctx.path()\\n         fparent1 = manifest1.get(fname, nullid)\\n         fparent2 = manifest2.get(fname, nullid)\\n         if isinstance(fctx, context.filectx):\\n             node = fctx.filenode()\\n             if node in [fparent1, fparent2]:\\n                 self.ui.debug('reusing %s filelog entry\\\\n' % fname)\\n                 if manifest1.flags(fname) != fctx.flags():\\n                     changelist.append(fname)\\n                 return node\\n \\n         flog = self.file(fname)\\n         meta = {}\\n         copy = fctx.renamed()\\n         if copy and copy[0] != fname:\\n             # Mark the new revision of this file as a copy of another\\n             # file.  This copy data will effectively act as a parent\\n             # of this new revision.  If this is a merge, the first\\n             # parent will be the nullid (meaning \\\"look up the copy data\\\")\\n             # and the second one will be the other parent.  For example:\\n             #\\n             # 0 --- 1 --- 3   rev1 changes file foo\\n             #   \\\\       \\/     rev2 renames foo to bar and changes it\\n             #    \\\\- 2 -\\/      rev3 should have bar with all changes and\\n             #                      should record that bar descends from\\n             #                      bar in rev2 and foo in rev1\\n             #\\n             # this allows this merge to succeed:\\n             #\\n             # 0 --- 1 --- 3   rev4 reverts the content change from rev2\\n             #   \\\\       \\/     merging rev3 and rev4 should use bar@rev2\\n             #    \\\\- 2 --- 4        as the merge base\\n             #\\n \\n             cfname = copy[0]\\n             crev = manifest1.get(cfname)\\n             newfparent = fparent2\\n \\n             if manifest2: # branch merge\\n                 if fparent2 == nullid or crev is None: # copied on remote side\\n                     if cfname in manifest2:\\n                         crev = manifest2[cfname]\\n                         newfparent = fparent1\\n \\n             # Here, we used to search backwards through history to try to find\\n             # where the file copy came from if the source of a copy was not in\\n             # the parent directory. However, this doesn't actually make sense to\\n             # do (what does a copy from something not in your working copy even\\n             # mean?) and it causes bugs (eg, issue4476). Instead, we will warn\\n             # the user that copy information was dropped, so if they didn't\\n             # expect this outcome it can be fixed, but this is the correct\\n             # behavior in this circumstance.\\n \\n             if crev:\\n                 self.ui.debug(\\\" %s: copy %s:%s\\\\n\\\" % (fname, cfname, hex(crev)))\\n                 meta[\\\"copy\\\"] = cfname\\n                 meta[\\\"copyrev\\\"] = hex(crev)\\n                 fparent1, fparent2 = nullid, newfparent\\n             else:\\n                 self.ui.warn(_(\\\"warning: can't find ancestor for '%s' \\\"\\n                                \\\"copied from '%s'!\\\\n\\\") % (fname, cfname))\\n \\n         elif fparent1 == nullid:\\n             fparent1, fparent2 = fparent2, nullid\\n         elif fparent2 != nullid:\\n             # is one parent an ancestor of the other?\\n             fparentancestors = flog.commonancestorsheads(fparent1, fparent2)\\n             if fparent1 in fparentancestors:\\n                 fparent1, fparent2 = fparent2, nullid\\n             elif fparent2 in fparentancestors:\\n                 fparent2 = nullid\\n \\n         # is the file changed?\\n         text = fctx.data()\\n         if fparent2 != nullid or flog.cmp(fparent1, text) or meta:\\n             changelist.append(fname)\\n             return flog.add(text, meta, tr, linkrev, fparent1, fparent2)\\n         # are just the flags changed during merge?\\n         elif fname in manifest1 and manifest1.flags(fname) != fctx.flags():\\n             changelist.append(fname)\\n \\n         return fparent1\\n \\n     def checkcommitpatterns(self, wctx, vdirs, match, status, fail):\\n         \\\"\\\"\\\"check for commit arguments that aren't committable\\\"\\\"\\\"\\n         if match.isexact() or match.prefix():\\n             matched = set(status.modified + status.added + status.removed)\\n \\n             for f in match.files():\\n                 f = self.dirstate.normalize(f)\\n                 if f == '.' or f in matched or f in wctx.substate:\\n                     continue\\n                 if f in status.deleted:\\n                     fail(f, _('file not found!'))\\n                 if f in vdirs: # visited directory\\n                     d = f + '\\/'\\n                     for mf in matched:\\n                         if mf.startswith(d):\\n                             break\\n                     else:\\n                         fail(f, _(\\\"no match under directory!\\\"))\\n                 elif f not in self.dirstate:\\n                     fail(f, _(\\\"file not tracked!\\\"))\\n \\n     @unfilteredmethod\\n     def commit(self, text=\\\"\\\", user=None, date=None, match=None, force=False,\\n                editor=False, extra=None):\\n         \\\"\\\"\\\"Add a new revision to current repository.\\n \\n         Revision information is gathered from the working directory,\\n         match can be used to filter the committed files. If editor is\\n         supplied, it is called to get a commit message.\\n         \\\"\\\"\\\"\\n         if extra is None:\\n             extra = {}\\n \\n         def fail(f, msg):\\n             raise error.Abort('%s: %s' % (f, msg))\\n \\n         if not match:\\n             match = matchmod.always(self.root, '')\\n \\n         if not force:\\n             vdirs = []\\n             match.explicitdir = vdirs.append\\n             match.bad = fail\\n \\n         wlock = lock = tr = None\\n         try:\\n             wlock = self.wlock()\\n             lock = self.lock() # for recent changelog (see issue4368)\\n \\n             wctx = self[None]\\n             merge = len(wctx.parents()) \\u003e 1\\n \\n             if not force and merge and not match.always():\\n                 raise error.Abort(_('cannot partially commit a merge '\\n                                    '(do not specify files or patterns)'))\\n \\n             status = self.status(match=match, clean=force)\\n             if force:\\n                 status.modified.extend(status.clean) # mq may commit clean files\\n \\n             # check subrepos\\n             subs, commitsubs, newstate = subrepo.precommit(\\n                 self.ui, wctx, status, match, force=force)\\n \\n             # make sure all explicit patterns are matched\\n             if not force:\\n                 self.checkcommitpatterns(wctx, vdirs, match, status, fail)\\n \\n             cctx = context.workingcommitctx(self, status,\\n                                             text, user, date, extra)\\n \\n             # internal config: ui.allowemptycommit\\n             allowemptycommit = (wctx.branch() != wctx.p1().branch()\\n                                 or extra.get('close') or merge or cctx.files()\\n                                 or self.ui.configbool('ui', 'allowemptycommit'))\\n             if not allowemptycommit:\\n                 return None\\n \\n             if merge and cctx.deleted():\\n                 raise error.Abort(_(\\\"cannot commit merge with missing files\\\"))\\n \\n             ms = mergemod.mergestate.read(self)\\n             mergeutil.checkunresolved(ms)\\n \\n             if editor:\\n                 cctx._text = editor(self, cctx, subs)\\n             edited = (text != cctx._text)\\n \\n             # Save commit message in case this transaction gets rolled back\\n             # (e.g. by a pretxncommit hook).  Leave the content alone on\\n             # the assumption that the user will use the same editor again.\\n             msgfn = self.savecommitmessage(cctx._text)\\n \\n             # commit subs and write new state\\n             if subs:\\n                 for s in sorted(commitsubs):\\n                     sub = wctx.sub(s)\\n                     self.ui.status(_('committing subrepository %s\\\\n') %\\n                         subrepo.subrelpath(sub))\\n                     sr = sub.commit(cctx._text, user, date)\\n                     newstate[s] = (newstate[s][0], sr)\\n                 subrepo.writestate(self, newstate)\\n \\n             p1, p2 = self.dirstate.parents()\\n             hookp1, hookp2 = hex(p1), (p2 != nullid and hex(p2) or '')\\n             try:\\n                 self.hook(\\\"precommit\\\", throw=True, parent1=hookp1,\\n                           parent2=hookp2)\\n                 tr = self.transaction('commit')\\n                 ret = self.commitctx(cctx, True)\\n             except: # re-raises\\n                 if edited:\\n                     self.ui.write(\\n                         _('note: commit message saved in %s\\\\n') % msgfn)\\n                 raise\\n             # update bookmarks, dirstate and mergestate\\n             bookmarks.update(self, [p1, p2], ret)\\n             cctx.markcommitted(ret)\\n             ms.reset()\\n             tr.close()\\n \\n         finally:\\n             lockmod.release(tr, lock, wlock)\\n \\n         def commithook(node=hex(ret), parent1=hookp1, parent2=hookp2):\\n             # hack for command that use a temporary commit (eg: histedit)\\n             # temporary commit got stripped before hook release\\n             if self.changelog.hasnode(ret):\\n                 self.hook(\\\"commit\\\", node=node, parent1=parent1,\\n                           parent2=parent2)\\n         self._afterlock(commithook)\\n         return ret\\n \\n     @unfilteredmethod\\n     def commitctx(self, ctx, error=False):\\n         \\\"\\\"\\\"Add a new revision to current repository.\\n         Revision information is passed via the context argument.\\n         \\\"\\\"\\\"\\n \\n         tr = None\\n         p1, p2 = ctx.p1(), ctx.p2()\\n         user = ctx.user()\\n \\n         lock = self.lock()\\n         try:\\n             tr = self.transaction(\\\"commit\\\")\\n             trp = weakref.proxy(tr)\\n \\n             if ctx.manifestnode():\\n                 # reuse an existing manifest revision\\n                 mn = ctx.manifestnode()\\n                 files = ctx.files()\\n             elif ctx.files():\\n                 m1ctx = p1.manifestctx()\\n                 m2ctx = p2.manifestctx()\\n                 mctx = m1ctx.copy()\\n \\n                 m = mctx.read()\\n                 m1 = m1ctx.read()\\n                 m2 = m2ctx.read()\\n \\n                 # check in files\\n                 added = []\\n                 changed = []\\n                 removed = list(ctx.removed())\\n                 linkrev = len(self)\\n                 self.ui.note(_(\\\"committing files:\\\\n\\\"))\\n                 for f in sorted(ctx.modified() + ctx.added()):\\n                     self.ui.note(f + \\\"\\\\n\\\")\\n                     try:\\n                         fctx = ctx[f]\\n                         if fctx is None:\\n                             removed.append(f)\\n                         else:\\n                             added.append(f)\\n                             m[f] = self._filecommit(fctx, m1, m2, linkrev,\\n                                                     trp, changed)\\n                             m.setflag(f, fctx.flags())\\n                     except OSError as inst:\\n                         self.ui.warn(_(\\\"trouble committing %s!\\\\n\\\") % f)\\n                         raise\\n                     except IOError as inst:\\n                         errcode = getattr(inst, 'errno', errno.ENOENT)\\n                         if error or errcode and errcode != errno.ENOENT:\\n                             self.ui.warn(_(\\\"trouble committing %s!\\\\n\\\") % f)\\n                         raise\\n \\n                 # update manifest\\n                 self.ui.note(_(\\\"committing manifest\\\\n\\\"))\\n                 removed = [f for f in sorted(removed) if f in m1 or f in m2]\\n                 drop = [f for f in removed if f in m]\\n                 for f in drop:\\n                     del m[f]\\n                 mn = mctx.write(trp, linkrev,\\n                                 p1.manifestnode(), p2.manifestnode(),\\n                                 added, drop)\\n                 files = changed + removed\\n             else:\\n                 mn = p1.manifestnode()\\n                 files = []\\n \\n             # update changelog\\n             self.ui.note(_(\\\"committing changelog\\\\n\\\"))\\n             self.changelog.delayupdate(tr)\\n             n = self.changelog.add(mn, files, ctx.description(),\\n                                    trp, p1.node(), p2.node(),\\n                                    user, ctx.date(), ctx.extra().copy())\\n             xp1, xp2 = p1.hex(), p2 and p2.hex() or ''\\n             self.hook('pretxncommit', throw=True, node=hex(n), parent1=xp1,\\n                       parent2=xp2)\\n             # set the new commit is proper phase\\n             targetphase = subrepo.newcommitphase(self.ui, ctx)\\n             if targetphase:\\n                 # retract boundary do not alter parent changeset.\\n                 # if a parent have higher the resulting phase will\\n                 # be compliant anyway\\n                 #\\n                 # if minimal phase was 0 we don't need to retract anything\\n                 phases.registernew(self, tr, targetphase, [n])\\n             tr.close()\\n             return n\\n         finally:\\n             if tr:\\n                 tr.release()\\n             lock.release()\\n \\n     @unfilteredmethod\\n     def destroying(self):\\n         '''Inform the repository that nodes are about to be destroyed.\\n         Intended for use by strip and rollback, so there's a common\\n         place for anything that has to be done before destroying history.\\n \\n         This is mostly useful for saving state that is in memory and waiting\\n         to be flushed when the current lock is released. Because a call to\\n         destroyed is imminent, the repo will be invalidated causing those\\n         changes to stay in memory (waiting for the next unlock), or vanish\\n         completely.\\n         '''\\n         # When using the same lock to commit and strip, the phasecache is left\\n         # dirty after committing. Then when we strip, the repo is invalidated,\\n         # causing those changes to disappear.\\n         if '_phasecache' in vars(self):\\n             self._phasecache.write()\\n \\n     @unfilteredmethod\\n     def destroyed(self):\\n         '''Inform the repository that nodes have been destroyed.\\n         Intended for use by strip and rollback, so there's a common\\n         place for anything that has to be done after destroying history.\\n         '''\\n         # When one tries to:\\n         # 1) destroy nodes thus calling this method (e.g. strip)\\n         # 2) use phasecache somewhere (e.g. commit)\\n         #\\n         # then 2) will fail because the phasecache contains nodes that were\\n         # removed. We can either remove phasecache from the filecache,\\n         # causing it to reload next time it is accessed, or simply filter\\n         # the removed nodes now and write the updated cache.\\n         self._phasecache.filterunknown(self)\\n         self._phasecache.write()\\n \\n         # refresh all repository caches\\n         self.updatecaches()\\n \\n         # Ensure the persistent tag cache is updated.  Doing it now\\n         # means that the tag cache only has to worry about destroyed\\n         # heads immediately after a strip\\/rollback.  That in turn\\n         # guarantees that \\\"cachetip == currenttip\\\" (comparing both rev\\n         # and node) always means no nodes have been added or destroyed.\\n \\n         # XXX this is suboptimal when qrefresh'ing: we strip the current\\n         # head, refresh the tag cache, then immediately add a new head.\\n         # But I think doing it this way is necessary for the \\\"instant\\n         # tag cache retrieval\\\" case to work.\\n         self.invalidate()\\n \\n     def walk(self, match, node=None):\\n         '''\\n         walk recursively through the directory tree or a given\\n         changeset, finding all files matched by the match\\n         function\\n         '''\\n         self.ui.deprecwarn('use repo[node].walk instead of repo.walk', '4.3')\\n         return self[node].walk(match)\\n \\n     def status(self, node1='.', node2=None, match=None,\\n                ignored=False, clean=False, unknown=False,\\n                listsubrepos=False):\\n         '''a convenience method that calls node1.status(node2)'''\\n         return self[node1].status(node2, match, ignored, clean, unknown,\\n                                   listsubrepos)\\n \\n     def addpostdsstatus(self, ps):\\n         \\\"\\\"\\\"Add a callback to run within the wlock, at the point at which status\\n         fixups happen.\\n \\n         On status completion, callback(wctx, status) will be called with the\\n         wlock held, unless the dirstate has changed from underneath or the wlock\\n         couldn't be grabbed.\\n \\n         Callbacks should not capture and use a cached copy of the dirstate --\\n         it might change in the meanwhile. Instead, they should access the\\n         dirstate via wctx.repo().dirstate.\\n \\n         This list is emptied out after each status run -- extensions should\\n         make sure it adds to this list each time dirstate.status is called.\\n         Extensions should also make sure they don't call this for statuses\\n         that don't involve the dirstate.\\n         \\\"\\\"\\\"\\n \\n         # The list is located here for uniqueness reasons -- it is actually\\n         # managed by the workingctx, but that isn't unique per-repo.\\n         self._postdsstatus.append(ps)\\n \\n     def postdsstatus(self):\\n         \\\"\\\"\\\"Used by workingctx to get the list of post-dirstate-status hooks.\\\"\\\"\\\"\\n         return self._postdsstatus\\n \\n     def clearpostdsstatus(self):\\n         \\\"\\\"\\\"Used by workingctx to clear post-dirstate-status hooks.\\\"\\\"\\\"\\n         del self._postdsstatus[:]\\n \\n     def heads(self, start=None):\\n         if start is None:\\n             cl = self.changelog\\n             headrevs = reversed(cl.headrevs())\\n             return [cl.node(rev) for rev in headrevs]\\n \\n         heads = self.changelog.heads(start)\\n         # sort the output in rev descending order\\n         return sorted(heads, key=self.changelog.rev, reverse=True)\\n \\n     def branchheads(self, branch=None, start=None, closed=False):\\n         '''return a (possibly filtered) list of heads for the given branch\\n \\n         Heads are returned in topological order, from newest to oldest.\\n         If branch is None, use the dirstate branch.\\n         If start is not None, return only heads reachable from start.\\n         If closed is True, return heads that are marked as closed as well.\\n         '''\\n         if branch is None:\\n             branch = self[None].branch()\\n         branches = self.branchmap()\\n         if branch not in branches:\\n             return []\\n         # the cache returns heads ordered lowest to highest\\n         bheads = list(reversed(branches.branchheads(branch, closed=closed)))\\n         if start is not None:\\n             # filter out the heads that cannot be reached from startrev\\n             fbheads = set(self.changelog.nodesbetween([start], bheads)[2])\\n             bheads = [h for h in bheads if h in fbheads]\\n         return bheads\\n \\n     def branches(self, nodes):\\n         if not nodes:\\n             nodes = [self.changelog.tip()]\\n         b = []\\n         for n in nodes:\\n             t = n\\n             while True:\\n                 p = self.changelog.parents(n)\\n                 if p[1] != nullid or p[0] == nullid:\\n                     b.append((t, n, p[0], p[1]))\\n                     break\\n                 n = p[0]\\n         return b\\n \\n     def between(self, pairs):\\n         r = []\\n \\n         for top, bottom in pairs:\\n             n, l, i = top, [], 0\\n             f = 1\\n \\n             while n != bottom and n != nullid:\\n                 p = self.changelog.parents(n)[0]\\n                 if i == f:\\n                     l.append(n)\\n                     f = f * 2\\n                 n = p\\n                 i += 1\\n \\n             r.append(l)\\n \\n         return r\\n \\n     def checkpush(self, pushop):\\n         \\\"\\\"\\\"Extensions can override this function if additional checks have\\n         to be performed before pushing, or call it if they override push\\n         command.\\n         \\\"\\\"\\\"\\n \\n     @unfilteredpropertycache\\n     def prepushoutgoinghooks(self):\\n         \\\"\\\"\\\"Return util.hooks consists of a pushop with repo, remote, outgoing\\n         methods, which are called before pushing changesets.\\n         \\\"\\\"\\\"\\n         return util.hooks()\\n \\n     def pushkey(self, namespace, key, old, new):\\n         try:\\n             tr = self.currenttransaction()\\n             hookargs = {}\\n             if tr is not None:\\n                 hookargs.update(tr.hookargs)\\n             hookargs['namespace'] = namespace\\n             hookargs['key'] = key\\n             hookargs['old'] = old\\n             hookargs['new'] = new\\n             self.hook('prepushkey', throw=True, **hookargs)\\n         except error.HookAbort as exc:\\n             self.ui.write_err(_(\\\"pushkey-abort: %s\\\\n\\\") % exc)\\n             if exc.hint:\\n                 self.ui.write_err(_(\\\"(%s)\\\\n\\\") % exc.hint)\\n             return False\\n         self.ui.debug('pushing key for \\\"%s:%s\\\"\\\\n' % (namespace, key))\\n         ret = pushkey.push(self, namespace, key, old, new)\\n         def runhook():\\n             self.hook('pushkey', namespace=namespace, key=key, old=old, new=new,\\n                       ret=ret)\\n         self._afterlock(runhook)\\n         return ret\\n \\n     def listkeys(self, namespace):\\n         self.hook('prelistkeys', throw=True, namespace=namespace)\\n         self.ui.debug('listing keys for \\\"%s\\\"\\\\n' % namespace)\\n         values = pushkey.list(self, namespace)\\n         self.hook('listkeys', namespace=namespace, values=values)\\n         return values\\n \\n     def debugwireargs(self, one, two, three=None, four=None, five=None):\\n         '''used to test argument passing over the wire'''\\n         return \\\"%s %s %s %s %s\\\" % (one, two, three, four, five)\\n \\n     def savecommitmessage(self, text):\\n         fp = self.vfs('last-message.txt', 'wb')\\n         try:\\n             fp.write(text)\\n         finally:\\n             fp.close()\\n         return self.pathto(fp.name[len(self.root) + 1:])\\n \\n # used to avoid circular references so destructors work\\n def aftertrans(files):\\n     renamefiles = [tuple(t) for t in files]\\n     def a():\\n         for vfs, src, dest in renamefiles:\\n             # if src and dest refer to a same file, vfs.rename is a no-op,\\n             # leaving both src and dest on disk. delete dest to make sure\\n             # the rename couldn't be such a no-op.\\n             vfs.tryunlink(dest)\\n             try:\\n                 vfs.rename(src, dest)\\n             except OSError: # journal file does not yet exist\\n                 pass\\n     return a\\n \\n def undoname(fn):\\n     base, name = os.path.split(fn)\\n     assert name.startswith('journal')\\n     return os.path.join(base, name.replace('journal', 'undo', 1))\\n \\n def instance(ui, path, create):\\n     return localrepository(ui, util.urllocalpath(path), create)\\n \\n def islocal(path):\\n     return True\\n \\n def newreporequirements(repo):\\n     \\\"\\\"\\\"Determine the set of requirements for a new local repository.\\n \\n     Extensions can wrap this function to specify custom requirements for\\n     new repositories.\\n     \\\"\\\"\\\"\\n     ui = repo.ui\\n     requirements = {'revlogv1'}\\n     if ui.configbool('format', 'usestore'):\\n         requirements.add('store')\\n         if ui.configbool('format', 'usefncache'):\\n             requirements.add('fncache')\\n             if ui.configbool('format', 'dotencode'):\\n                 requirements.add('dotencode')\\n \\n     compengine = ui.config('experimental', 'format.compression')\\n     if compengine not in util.compengines:\\n         raise error.Abort(_('compression engine %s defined by '\\n                             'experimental.format.compression not available') %\\n                           compengine,\\n                           hint=_('run \\\"hg debuginstall\\\" to list available '\\n                                  'compression engines'))\\n \\n     # zlib is the historical default and doesn't need an explicit requirement.\\n     if compengine != 'zlib':\\n         requirements.add('exp-compression-%s' % compengine)\\n \\n     if scmutil.gdinitconfig(ui):\\n         requirements.add('generaldelta')\\n     if ui.configbool('experimental', 'treemanifest'):\\n         requirements.add('treemanifest')\\n     if ui.configbool('experimental', 'manifestv2'):\\n         requirements.add('manifestv2')\\n \\n     revlogv2 = ui.config('experimental', 'revlogv2')\\n     if revlogv2 == 'enable-unstable-format-and-corrupt-my-data':\\n         requirements.remove('revlogv1')\\n         # generaldelta is implied by revlogv2.\\n         requirements.discard('generaldelta')\\n         requirements.add(REVLOGV2_REQUIREMENT)\\n \\n     return requirements\\n\"}]}],\"properties\":{\"hg:meta\":{\"date\":\"1509404054 -19800\",\"node\":\"44fc1c1f1774a76423b9c732af6938435099bcc5\",\"user\":\"Pulkit Goyal \\u003c7895pulkit@gmail.com\\u003e\",\"parent\":\"8feef8ef8389a3b544e0a74624f1efc3a8d85d35\"}}}},\"error_code\":null,\"error_info\":null}"
                }
            }, 
            "request": {
                "method": "POST", 
                "uri": "https://phab.mercurial-scm.org//api/differential.querydiffs", 
                "headers": {
                    "content-type": [
                        "application/x-www-form-urlencoded"
                    ], 
                    "user-agent": [
                        "mercurial/proto-1.0 (Mercurial 5.2.2+620-6ee2ba170fe6+20200116)"
                    ], 
                    "accept": [
                        "application/mercurial-0.1"
                    ], 
                    "content-length": [
                        "146"
                    ], 
                    "host": [
                        "phab.mercurial-scm.org"
                    ]
                }, 
                "body": "params=%7B%22__conduit__%22%3A+%7B%22token%22%3A+%22cli-hahayouwish%22%7D%2C+%22ids%22%3A+%5B4092%5D%7D&output=json&__conduit__=1"
            }
        }, 
        {
            "response": {
                "headers": {
                    "x-content-type-options": [
                        "nosniff"
                    ], 
                    "x-xss-protection": [
                        "1; mode=block"
                    ], 
                    "content-type": [
                        "application/json"
                    ], 
                    "transfer-encoding": [
                        "chunked"
                    ], 
                    "strict-transport-security": [
                        "max-age=0; includeSubdomains; preload"
                    ], 
                    "date": [
                        "Fri, 17 Jan 2020 00:33:21 GMT"
                    ], 
                    "cache-control": [
                        "no-store"
                    ], 
                    "expires": [
                        "Sat, 01 Jan 2000 00:00:00 GMT"
                    ], 
                    "server": [
                        "Apache/2.4.10 (Debian)"
                    ], 
                    "x-frame-options": [
                        "Deny"
                    ], 
                    "referrer-policy": [
                        "no-referrer"
                    ]
                }, 
                "status": {
                    "code": 200, 
                    "message": "OK"
                }, 
                "body": {
                    "string": "{\"result\":\"diff --git a\\/mercurial\\/repoview.py b\\/mercurial\\/repoview.py\\n--- a\\/mercurial\\/repoview.py\\n+++ b\\/mercurial\\/repoview.py\\n@@ -185,6 +185,9 @@\\n     subclasses of `localrepo`. Eg: `bundlerepo` or `statichttprepo`.\\n     \\\"\\\"\\\"\\n \\n+    # hidden revs which should be visible\\n+    _visibilityexceptions = set()\\n+\\n     def __init__(self, repo, filtername):\\n         object.__setattr__(self, r'_unfilteredrepo', repo)\\n         object.__setattr__(self, r'filtername', filtername)\\n@@ -231,6 +234,14 @@\\n             return self\\n         return self.unfiltered().filtered(name)\\n \\n+    def addvisibilityexceptions(self, revs):\\n+        \\\"\\\"\\\"adds hidden revs which should be visible to set of exceptions\\\"\\\"\\\"\\n+        self._visibilityexceptions.update(revs)\\n+\\n+    def getvisibilityexceptions(self):\\n+        \\\"\\\"\\\"returns the set of hidden revs which should be visible\\\"\\\"\\\"\\n+        return self._visibilityexceptions\\n+\\n     # everything access are forwarded to the proxied repo\\n     def __getattr__(self, attr):\\n         return getattr(self._unfilteredrepo, attr)\\ndiff --git a\\/mercurial\\/localrepo.py b\\/mercurial\\/localrepo.py\\n--- a\\/mercurial\\/localrepo.py\\n+++ b\\/mercurial\\/localrepo.py\\n@@ -570,6 +570,14 @@\\n     def close(self):\\n         self._writecaches()\\n \\n+    def addvisibilityexceptions(self, exceptions):\\n+        # should be called on a filtered repository\\n+        pass\\n+\\n+    def getvisibilityexceptions(self):\\n+        # should be called on a filtered repository\\n+        return set()\\n+\\n     def _loadextensions(self):\\n         extensions.loadall(self.ui)\\n \\n\\n\",\"error_code\":null,\"error_info\":null}"
                }
            }, 
            "request": {
                "method": "POST", 
                "uri": "https://phab.mercurial-scm.org//api/differential.getrawdiff", 
                "headers": {
                    "content-type": [
                        "application/x-www-form-urlencoded"
                    ], 
                    "user-agent": [
                        "mercurial/proto-1.0 (Mercurial 5.2.2+620-6ee2ba170fe6+20200116)"
                    ], 
                    "accept": [
                        "application/mercurial-0.1"
                    ], 
                    "content-length": [
                        "143"
                    ], 
                    "host": [
                        "phab.mercurial-scm.org"
                    ]
                }, 
                "body": "params=%7B%22__conduit__%22%3A+%7B%22token%22%3A+%22cli-hahayouwish%22%7D%2C+%22diffID%22%3A+4092%7D&output=json&__conduit__=1"
            }
        }
    ], 
    "version": 1
}